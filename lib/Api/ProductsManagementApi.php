<?php
/**
 * ProductsManagementApi
 * PHP version 7.4
 *
 * @category Class
 * @package  Aurigma\BackOffice
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * BackOffice API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: backoffice-v1
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.4.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Aurigma\BackOffice\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Aurigma\BackOffice\ApiException;
use Aurigma\BackOffice\Configuration;
use Aurigma\BackOffice\HeaderSelector;
use Aurigma\BackOffice\ObjectSerializer;

/**
 * ProductsManagementApi Class Doc Comment
 *
 * @category Class
 * @package  Aurigma\BackOffice
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class ProductsManagementApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'productsManagementCreateDesignsConnections' => [
            'application/json',
        ],
        'productsManagementCreateDocumentsConnections' => [
            'application/json',
        ],
        'productsManagementCreateMockupsConnections' => [
            'application/json',
        ],
        'productsManagementCreateProduct' => [
            'application/json',
        ],
        'productsManagementDeleteProduct' => [
            'application/json',
        ],
        'productsManagementGetAllProducts' => [
            'application/json',
        ],
        'productsManagementGetAvailablePersonalizationWorkflows' => [
            'application/json',
        ],
        'productsManagementGetAvailableProcessingPipelines' => [
            'application/json',
        ],
        'productsManagementGetProduct' => [
            'application/json',
        ],
        'productsManagementGetProductOptions' => [
            'application/json',
        ],
        'productsManagementGetProductVariant' => [
            'application/json',
        ],
        'productsManagementGetProductVariantDesigns' => [
            'application/json',
        ],
        'productsManagementGetProductVariantDocuments' => [
            'application/json',
        ],
        'productsManagementGetProductVariantMockups' => [
            'application/json',
        ],
        'productsManagementGetProductVariants' => [
            'application/json',
        ],
        'productsManagementImportProducts' => [
            'multipart/form-data',
        ],
        'productsManagementRemoveDesignsConnections' => [
            'application/json',
        ],
        'productsManagementRemoveDocumentsConnections' => [
            'application/json',
        ],
        'productsManagementRemoveMockupsConnections' => [
            'application/json',
        ],
        'productsManagementSetProductVariantAvailability' => [
            'application/json',
        ],
        'productsManagementSetProductVariantPrice' => [
            'application/json',
        ],
        'productsManagementSetProductVariantSku' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation productsManagementCreateDesignsConnections
     *
     * Creates new designs connections for a specified product.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  \Aurigma\BackOffice\Model\CreateProductDesignConnectionsDto $create_product_design_connections_dto Product designs connections creation parameters. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementCreateDesignsConnections'] to see the possible values for this operation
     *
     * @throws \Aurigma\BackOffice\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function productsManagementCreateDesignsConnections($id, $tenant_id = null, $create_product_design_connections_dto = null, string $contentType = self::contentTypes['productsManagementCreateDesignsConnections'][0])
    {
        $this->productsManagementCreateDesignsConnectionsWithHttpInfo($id, $tenant_id, $create_product_design_connections_dto, $contentType);
    }

    /**
     * Operation productsManagementCreateDesignsConnectionsWithHttpInfo
     *
     * Creates new designs connections for a specified product.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  \Aurigma\BackOffice\Model\CreateProductDesignConnectionsDto $create_product_design_connections_dto Product designs connections creation parameters. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementCreateDesignsConnections'] to see the possible values for this operation
     *
     * @throws \Aurigma\BackOffice\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsManagementCreateDesignsConnectionsWithHttpInfo($id, $tenant_id = null, $create_product_design_connections_dto = null, string $contentType = self::contentTypes['productsManagementCreateDesignsConnections'][0])
    {
        $request = $this->productsManagementCreateDesignsConnectionsRequest($id, $tenant_id, $create_product_design_connections_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurigma\BackOffice\Model\MicrosoftAspNetCoreMvcProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurigma\BackOffice\Model\GeneralConflictDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsManagementCreateDesignsConnectionsAsync
     *
     * Creates new designs connections for a specified product.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  \Aurigma\BackOffice\Model\CreateProductDesignConnectionsDto $create_product_design_connections_dto Product designs connections creation parameters. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementCreateDesignsConnections'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsManagementCreateDesignsConnectionsAsync($id, $tenant_id = null, $create_product_design_connections_dto = null, string $contentType = self::contentTypes['productsManagementCreateDesignsConnections'][0])
    {
        return $this->productsManagementCreateDesignsConnectionsAsyncWithHttpInfo($id, $tenant_id, $create_product_design_connections_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsManagementCreateDesignsConnectionsAsyncWithHttpInfo
     *
     * Creates new designs connections for a specified product.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  \Aurigma\BackOffice\Model\CreateProductDesignConnectionsDto $create_product_design_connections_dto Product designs connections creation parameters. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementCreateDesignsConnections'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsManagementCreateDesignsConnectionsAsyncWithHttpInfo($id, $tenant_id = null, $create_product_design_connections_dto = null, string $contentType = self::contentTypes['productsManagementCreateDesignsConnections'][0])
    {
        $returnType = '';
        $request = $this->productsManagementCreateDesignsConnectionsRequest($id, $tenant_id, $create_product_design_connections_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsManagementCreateDesignsConnections'
     *
     * @param  int $id Product identifier. (required)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  \Aurigma\BackOffice\Model\CreateProductDesignConnectionsDto $create_product_design_connections_dto Product designs connections creation parameters. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementCreateDesignsConnections'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsManagementCreateDesignsConnectionsRequest($id, $tenant_id = null, $create_product_design_connections_dto = null, string $contentType = self::contentTypes['productsManagementCreateDesignsConnections'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productsManagementCreateDesignsConnections'
            );
        }




        $resourcePath = '/api/backoffice/v1/products/{id}/design-connections';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_id,
            'tenantId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_product_design_connections_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_product_design_connections_dto));
            } else {
                $httpBody = $create_product_design_connections_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsManagementCreateDocumentsConnections
     *
     * Creates new documents connections for a specified product.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  \Aurigma\BackOffice\Model\CreateProductDocumentConnectionsDto $create_product_document_connections_dto Product documents connections creation parameters. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementCreateDocumentsConnections'] to see the possible values for this operation
     *
     * @throws \Aurigma\BackOffice\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function productsManagementCreateDocumentsConnections($id, $tenant_id = null, $create_product_document_connections_dto = null, string $contentType = self::contentTypes['productsManagementCreateDocumentsConnections'][0])
    {
        $this->productsManagementCreateDocumentsConnectionsWithHttpInfo($id, $tenant_id, $create_product_document_connections_dto, $contentType);
    }

    /**
     * Operation productsManagementCreateDocumentsConnectionsWithHttpInfo
     *
     * Creates new documents connections for a specified product.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  \Aurigma\BackOffice\Model\CreateProductDocumentConnectionsDto $create_product_document_connections_dto Product documents connections creation parameters. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementCreateDocumentsConnections'] to see the possible values for this operation
     *
     * @throws \Aurigma\BackOffice\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsManagementCreateDocumentsConnectionsWithHttpInfo($id, $tenant_id = null, $create_product_document_connections_dto = null, string $contentType = self::contentTypes['productsManagementCreateDocumentsConnections'][0])
    {
        $request = $this->productsManagementCreateDocumentsConnectionsRequest($id, $tenant_id, $create_product_document_connections_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurigma\BackOffice\Model\MicrosoftAspNetCoreMvcProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurigma\BackOffice\Model\GeneralConflictDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsManagementCreateDocumentsConnectionsAsync
     *
     * Creates new documents connections for a specified product.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  \Aurigma\BackOffice\Model\CreateProductDocumentConnectionsDto $create_product_document_connections_dto Product documents connections creation parameters. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementCreateDocumentsConnections'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsManagementCreateDocumentsConnectionsAsync($id, $tenant_id = null, $create_product_document_connections_dto = null, string $contentType = self::contentTypes['productsManagementCreateDocumentsConnections'][0])
    {
        return $this->productsManagementCreateDocumentsConnectionsAsyncWithHttpInfo($id, $tenant_id, $create_product_document_connections_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsManagementCreateDocumentsConnectionsAsyncWithHttpInfo
     *
     * Creates new documents connections for a specified product.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  \Aurigma\BackOffice\Model\CreateProductDocumentConnectionsDto $create_product_document_connections_dto Product documents connections creation parameters. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementCreateDocumentsConnections'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsManagementCreateDocumentsConnectionsAsyncWithHttpInfo($id, $tenant_id = null, $create_product_document_connections_dto = null, string $contentType = self::contentTypes['productsManagementCreateDocumentsConnections'][0])
    {
        $returnType = '';
        $request = $this->productsManagementCreateDocumentsConnectionsRequest($id, $tenant_id, $create_product_document_connections_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsManagementCreateDocumentsConnections'
     *
     * @param  int $id Product identifier. (required)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  \Aurigma\BackOffice\Model\CreateProductDocumentConnectionsDto $create_product_document_connections_dto Product documents connections creation parameters. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementCreateDocumentsConnections'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsManagementCreateDocumentsConnectionsRequest($id, $tenant_id = null, $create_product_document_connections_dto = null, string $contentType = self::contentTypes['productsManagementCreateDocumentsConnections'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productsManagementCreateDocumentsConnections'
            );
        }




        $resourcePath = '/api/backoffice/v1/products/{id}/document-connections';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_id,
            'tenantId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_product_document_connections_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_product_document_connections_dto));
            } else {
                $httpBody = $create_product_document_connections_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsManagementCreateMockupsConnections
     *
     * Creates new mockups connections for a specified product.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  \Aurigma\BackOffice\Model\CreateProductMockupConnectionsDto $create_product_mockup_connections_dto Product mockups connections creation parameters. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementCreateMockupsConnections'] to see the possible values for this operation
     *
     * @throws \Aurigma\BackOffice\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function productsManagementCreateMockupsConnections($id, $tenant_id = null, $create_product_mockup_connections_dto = null, string $contentType = self::contentTypes['productsManagementCreateMockupsConnections'][0])
    {
        $this->productsManagementCreateMockupsConnectionsWithHttpInfo($id, $tenant_id, $create_product_mockup_connections_dto, $contentType);
    }

    /**
     * Operation productsManagementCreateMockupsConnectionsWithHttpInfo
     *
     * Creates new mockups connections for a specified product.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  \Aurigma\BackOffice\Model\CreateProductMockupConnectionsDto $create_product_mockup_connections_dto Product mockups connections creation parameters. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementCreateMockupsConnections'] to see the possible values for this operation
     *
     * @throws \Aurigma\BackOffice\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsManagementCreateMockupsConnectionsWithHttpInfo($id, $tenant_id = null, $create_product_mockup_connections_dto = null, string $contentType = self::contentTypes['productsManagementCreateMockupsConnections'][0])
    {
        $request = $this->productsManagementCreateMockupsConnectionsRequest($id, $tenant_id, $create_product_mockup_connections_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurigma\BackOffice\Model\MicrosoftAspNetCoreMvcProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurigma\BackOffice\Model\GeneralConflictDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsManagementCreateMockupsConnectionsAsync
     *
     * Creates new mockups connections for a specified product.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  \Aurigma\BackOffice\Model\CreateProductMockupConnectionsDto $create_product_mockup_connections_dto Product mockups connections creation parameters. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementCreateMockupsConnections'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsManagementCreateMockupsConnectionsAsync($id, $tenant_id = null, $create_product_mockup_connections_dto = null, string $contentType = self::contentTypes['productsManagementCreateMockupsConnections'][0])
    {
        return $this->productsManagementCreateMockupsConnectionsAsyncWithHttpInfo($id, $tenant_id, $create_product_mockup_connections_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsManagementCreateMockupsConnectionsAsyncWithHttpInfo
     *
     * Creates new mockups connections for a specified product.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  \Aurigma\BackOffice\Model\CreateProductMockupConnectionsDto $create_product_mockup_connections_dto Product mockups connections creation parameters. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementCreateMockupsConnections'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsManagementCreateMockupsConnectionsAsyncWithHttpInfo($id, $tenant_id = null, $create_product_mockup_connections_dto = null, string $contentType = self::contentTypes['productsManagementCreateMockupsConnections'][0])
    {
        $returnType = '';
        $request = $this->productsManagementCreateMockupsConnectionsRequest($id, $tenant_id, $create_product_mockup_connections_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsManagementCreateMockupsConnections'
     *
     * @param  int $id Product identifier. (required)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  \Aurigma\BackOffice\Model\CreateProductMockupConnectionsDto $create_product_mockup_connections_dto Product mockups connections creation parameters. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementCreateMockupsConnections'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsManagementCreateMockupsConnectionsRequest($id, $tenant_id = null, $create_product_mockup_connections_dto = null, string $contentType = self::contentTypes['productsManagementCreateMockupsConnections'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productsManagementCreateMockupsConnections'
            );
        }




        $resourcePath = '/api/backoffice/v1/products/{id}/mockup-connections';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_id,
            'tenantId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_product_mockup_connections_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_product_mockup_connections_dto));
            } else {
                $httpBody = $create_product_mockup_connections_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsManagementCreateProduct
     *
     * Creates a new product and returns its description.
     *
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  \Aurigma\BackOffice\Model\CreateProductDto $create_product_dto create_product_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementCreateProduct'] to see the possible values for this operation
     *
     * @throws \Aurigma\BackOffice\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Aurigma\BackOffice\Model\ProductDto
     */
    public function productsManagementCreateProduct($tenant_id = null, $create_product_dto = null, string $contentType = self::contentTypes['productsManagementCreateProduct'][0])
    {
        list($response) = $this->productsManagementCreateProductWithHttpInfo($tenant_id, $create_product_dto, $contentType);
        return $response;
    }

    /**
     * Operation productsManagementCreateProductWithHttpInfo
     *
     * Creates a new product and returns its description.
     *
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  \Aurigma\BackOffice\Model\CreateProductDto $create_product_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementCreateProduct'] to see the possible values for this operation
     *
     * @throws \Aurigma\BackOffice\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Aurigma\BackOffice\Model\ProductDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsManagementCreateProductWithHttpInfo($tenant_id = null, $create_product_dto = null, string $contentType = self::contentTypes['productsManagementCreateProduct'][0])
    {
        $request = $this->productsManagementCreateProductRequest($tenant_id, $create_product_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Aurigma\BackOffice\Model\ProductDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Aurigma\BackOffice\Model\ProductDto' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Aurigma\BackOffice\Model\ProductDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Aurigma\BackOffice\Model\ProductDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurigma\BackOffice\Model\ProductDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsManagementCreateProductAsync
     *
     * Creates a new product and returns its description.
     *
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  \Aurigma\BackOffice\Model\CreateProductDto $create_product_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementCreateProduct'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsManagementCreateProductAsync($tenant_id = null, $create_product_dto = null, string $contentType = self::contentTypes['productsManagementCreateProduct'][0])
    {
        return $this->productsManagementCreateProductAsyncWithHttpInfo($tenant_id, $create_product_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsManagementCreateProductAsyncWithHttpInfo
     *
     * Creates a new product and returns its description.
     *
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  \Aurigma\BackOffice\Model\CreateProductDto $create_product_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementCreateProduct'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsManagementCreateProductAsyncWithHttpInfo($tenant_id = null, $create_product_dto = null, string $contentType = self::contentTypes['productsManagementCreateProduct'][0])
    {
        $returnType = '\Aurigma\BackOffice\Model\ProductDto';
        $request = $this->productsManagementCreateProductRequest($tenant_id, $create_product_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsManagementCreateProduct'
     *
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  \Aurigma\BackOffice\Model\CreateProductDto $create_product_dto (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementCreateProduct'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsManagementCreateProductRequest($tenant_id = null, $create_product_dto = null, string $contentType = self::contentTypes['productsManagementCreateProduct'][0])
    {




        $resourcePath = '/api/backoffice/v1/products';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_id,
            'tenantId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_product_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_product_dto));
            } else {
                $httpBody = $create_product_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsManagementDeleteProduct
     *
     * Deletes a product by its identifier.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementDeleteProduct'] to see the possible values for this operation
     *
     * @throws \Aurigma\BackOffice\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function productsManagementDeleteProduct($id, $tenant_id = null, string $contentType = self::contentTypes['productsManagementDeleteProduct'][0])
    {
        $this->productsManagementDeleteProductWithHttpInfo($id, $tenant_id, $contentType);
    }

    /**
     * Operation productsManagementDeleteProductWithHttpInfo
     *
     * Deletes a product by its identifier.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementDeleteProduct'] to see the possible values for this operation
     *
     * @throws \Aurigma\BackOffice\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsManagementDeleteProductWithHttpInfo($id, $tenant_id = null, string $contentType = self::contentTypes['productsManagementDeleteProduct'][0])
    {
        $request = $this->productsManagementDeleteProductRequest($id, $tenant_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurigma\BackOffice\Model\MicrosoftAspNetCoreMvcProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurigma\BackOffice\Model\GeneralConflictDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsManagementDeleteProductAsync
     *
     * Deletes a product by its identifier.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementDeleteProduct'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsManagementDeleteProductAsync($id, $tenant_id = null, string $contentType = self::contentTypes['productsManagementDeleteProduct'][0])
    {
        return $this->productsManagementDeleteProductAsyncWithHttpInfo($id, $tenant_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsManagementDeleteProductAsyncWithHttpInfo
     *
     * Deletes a product by its identifier.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementDeleteProduct'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsManagementDeleteProductAsyncWithHttpInfo($id, $tenant_id = null, string $contentType = self::contentTypes['productsManagementDeleteProduct'][0])
    {
        $returnType = '';
        $request = $this->productsManagementDeleteProductRequest($id, $tenant_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsManagementDeleteProduct'
     *
     * @param  int $id Product identifier. (required)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementDeleteProduct'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsManagementDeleteProductRequest($id, $tenant_id = null, string $contentType = self::contentTypes['productsManagementDeleteProduct'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productsManagementDeleteProduct'
            );
        }



        $resourcePath = '/api/backoffice/v1/products/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_id,
            'tenantId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsManagementGetAllProducts
     *
     * Returns all products, relevant to the specified query parameters.
     *
     * @param  int $skip Defines page start offset from beginning of sorted result list. (optional)
     * @param  int $take Defines page length (how many consequent items of sorted result list should be taken). (optional)
     * @param  string $sorting Defines sorting order of result list e.g.: \&quot;Title ASC, LastModified DESC\&quot;. (optional)
     * @param  string $search Search string for partial match. (optional)
     * @param  string $sku SKU of linked ecommerce product. (optional)
     * @param  string[] $tags List of tags that product should have. (optional)
     * @param  string $custom_fields Serialized custom fields dictionary filter. For example: {\&quot;public\&quot;:\&quot;true\&quot;,\&quot;name\&quot;:\&quot;my item\&quot;}. (optional)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementGetAllProducts'] to see the possible values for this operation
     *
     * @throws \Aurigma\BackOffice\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Aurigma\BackOffice\Model\PagedOfProductDto
     */
    public function productsManagementGetAllProducts($skip = null, $take = null, $sorting = null, $search = null, $sku = null, $tags = null, $custom_fields = null, $tenant_id = null, string $contentType = self::contentTypes['productsManagementGetAllProducts'][0])
    {
        list($response) = $this->productsManagementGetAllProductsWithHttpInfo($skip, $take, $sorting, $search, $sku, $tags, $custom_fields, $tenant_id, $contentType);
        return $response;
    }

    /**
     * Operation productsManagementGetAllProductsWithHttpInfo
     *
     * Returns all products, relevant to the specified query parameters.
     *
     * @param  int $skip Defines page start offset from beginning of sorted result list. (optional)
     * @param  int $take Defines page length (how many consequent items of sorted result list should be taken). (optional)
     * @param  string $sorting Defines sorting order of result list e.g.: \&quot;Title ASC, LastModified DESC\&quot;. (optional)
     * @param  string $search Search string for partial match. (optional)
     * @param  string $sku SKU of linked ecommerce product. (optional)
     * @param  string[] $tags List of tags that product should have. (optional)
     * @param  string $custom_fields Serialized custom fields dictionary filter. For example: {\&quot;public\&quot;:\&quot;true\&quot;,\&quot;name\&quot;:\&quot;my item\&quot;}. (optional)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementGetAllProducts'] to see the possible values for this operation
     *
     * @throws \Aurigma\BackOffice\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Aurigma\BackOffice\Model\PagedOfProductDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsManagementGetAllProductsWithHttpInfo($skip = null, $take = null, $sorting = null, $search = null, $sku = null, $tags = null, $custom_fields = null, $tenant_id = null, string $contentType = self::contentTypes['productsManagementGetAllProducts'][0])
    {
        $request = $this->productsManagementGetAllProductsRequest($skip, $take, $sorting, $search, $sku, $tags, $custom_fields, $tenant_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Aurigma\BackOffice\Model\PagedOfProductDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Aurigma\BackOffice\Model\PagedOfProductDto' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Aurigma\BackOffice\Model\PagedOfProductDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Aurigma\BackOffice\Model\PagedOfProductDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurigma\BackOffice\Model\PagedOfProductDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsManagementGetAllProductsAsync
     *
     * Returns all products, relevant to the specified query parameters.
     *
     * @param  int $skip Defines page start offset from beginning of sorted result list. (optional)
     * @param  int $take Defines page length (how many consequent items of sorted result list should be taken). (optional)
     * @param  string $sorting Defines sorting order of result list e.g.: \&quot;Title ASC, LastModified DESC\&quot;. (optional)
     * @param  string $search Search string for partial match. (optional)
     * @param  string $sku SKU of linked ecommerce product. (optional)
     * @param  string[] $tags List of tags that product should have. (optional)
     * @param  string $custom_fields Serialized custom fields dictionary filter. For example: {\&quot;public\&quot;:\&quot;true\&quot;,\&quot;name\&quot;:\&quot;my item\&quot;}. (optional)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementGetAllProducts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsManagementGetAllProductsAsync($skip = null, $take = null, $sorting = null, $search = null, $sku = null, $tags = null, $custom_fields = null, $tenant_id = null, string $contentType = self::contentTypes['productsManagementGetAllProducts'][0])
    {
        return $this->productsManagementGetAllProductsAsyncWithHttpInfo($skip, $take, $sorting, $search, $sku, $tags, $custom_fields, $tenant_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsManagementGetAllProductsAsyncWithHttpInfo
     *
     * Returns all products, relevant to the specified query parameters.
     *
     * @param  int $skip Defines page start offset from beginning of sorted result list. (optional)
     * @param  int $take Defines page length (how many consequent items of sorted result list should be taken). (optional)
     * @param  string $sorting Defines sorting order of result list e.g.: \&quot;Title ASC, LastModified DESC\&quot;. (optional)
     * @param  string $search Search string for partial match. (optional)
     * @param  string $sku SKU of linked ecommerce product. (optional)
     * @param  string[] $tags List of tags that product should have. (optional)
     * @param  string $custom_fields Serialized custom fields dictionary filter. For example: {\&quot;public\&quot;:\&quot;true\&quot;,\&quot;name\&quot;:\&quot;my item\&quot;}. (optional)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementGetAllProducts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsManagementGetAllProductsAsyncWithHttpInfo($skip = null, $take = null, $sorting = null, $search = null, $sku = null, $tags = null, $custom_fields = null, $tenant_id = null, string $contentType = self::contentTypes['productsManagementGetAllProducts'][0])
    {
        $returnType = '\Aurigma\BackOffice\Model\PagedOfProductDto';
        $request = $this->productsManagementGetAllProductsRequest($skip, $take, $sorting, $search, $sku, $tags, $custom_fields, $tenant_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsManagementGetAllProducts'
     *
     * @param  int $skip Defines page start offset from beginning of sorted result list. (optional)
     * @param  int $take Defines page length (how many consequent items of sorted result list should be taken). (optional)
     * @param  string $sorting Defines sorting order of result list e.g.: \&quot;Title ASC, LastModified DESC\&quot;. (optional)
     * @param  string $search Search string for partial match. (optional)
     * @param  string $sku SKU of linked ecommerce product. (optional)
     * @param  string[] $tags List of tags that product should have. (optional)
     * @param  string $custom_fields Serialized custom fields dictionary filter. For example: {\&quot;public\&quot;:\&quot;true\&quot;,\&quot;name\&quot;:\&quot;my item\&quot;}. (optional)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementGetAllProducts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsManagementGetAllProductsRequest($skip = null, $take = null, $sorting = null, $search = null, $sku = null, $tags = null, $custom_fields = null, $tenant_id = null, string $contentType = self::contentTypes['productsManagementGetAllProducts'][0])
    {










        $resourcePath = '/api/backoffice/v1/products';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $skip,
            'skip', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $take,
            'take', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sorting,
            'sorting', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $search,
            'search', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sku,
            'sku', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tags,
            'tags', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $custom_fields,
            'customFields', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_id,
            'tenantId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsManagementGetAvailablePersonalizationWorkflows
     *
     * Returns all available product personalization workflows.
     *
     * @param  int $skip Defines page start offset from beginning of sorted result list. (optional)
     * @param  int $take Defines page length (how many consequent items of sorted result list should be taken). (optional)
     * @param  string $search Search string for partial by personalization workflow name. (optional)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementGetAvailablePersonalizationWorkflows'] to see the possible values for this operation
     *
     * @throws \Aurigma\BackOffice\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Aurigma\BackOffice\Model\PagedOfPersonalizationWorkflowDto
     */
    public function productsManagementGetAvailablePersonalizationWorkflows($skip = null, $take = null, $search = null, $tenant_id = null, string $contentType = self::contentTypes['productsManagementGetAvailablePersonalizationWorkflows'][0])
    {
        list($response) = $this->productsManagementGetAvailablePersonalizationWorkflowsWithHttpInfo($skip, $take, $search, $tenant_id, $contentType);
        return $response;
    }

    /**
     * Operation productsManagementGetAvailablePersonalizationWorkflowsWithHttpInfo
     *
     * Returns all available product personalization workflows.
     *
     * @param  int $skip Defines page start offset from beginning of sorted result list. (optional)
     * @param  int $take Defines page length (how many consequent items of sorted result list should be taken). (optional)
     * @param  string $search Search string for partial by personalization workflow name. (optional)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementGetAvailablePersonalizationWorkflows'] to see the possible values for this operation
     *
     * @throws \Aurigma\BackOffice\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Aurigma\BackOffice\Model\PagedOfPersonalizationWorkflowDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsManagementGetAvailablePersonalizationWorkflowsWithHttpInfo($skip = null, $take = null, $search = null, $tenant_id = null, string $contentType = self::contentTypes['productsManagementGetAvailablePersonalizationWorkflows'][0])
    {
        $request = $this->productsManagementGetAvailablePersonalizationWorkflowsRequest($skip, $take, $search, $tenant_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Aurigma\BackOffice\Model\PagedOfPersonalizationWorkflowDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Aurigma\BackOffice\Model\PagedOfPersonalizationWorkflowDto' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Aurigma\BackOffice\Model\PagedOfPersonalizationWorkflowDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Aurigma\BackOffice\Model\PagedOfPersonalizationWorkflowDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurigma\BackOffice\Model\PagedOfPersonalizationWorkflowDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsManagementGetAvailablePersonalizationWorkflowsAsync
     *
     * Returns all available product personalization workflows.
     *
     * @param  int $skip Defines page start offset from beginning of sorted result list. (optional)
     * @param  int $take Defines page length (how many consequent items of sorted result list should be taken). (optional)
     * @param  string $search Search string for partial by personalization workflow name. (optional)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementGetAvailablePersonalizationWorkflows'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsManagementGetAvailablePersonalizationWorkflowsAsync($skip = null, $take = null, $search = null, $tenant_id = null, string $contentType = self::contentTypes['productsManagementGetAvailablePersonalizationWorkflows'][0])
    {
        return $this->productsManagementGetAvailablePersonalizationWorkflowsAsyncWithHttpInfo($skip, $take, $search, $tenant_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsManagementGetAvailablePersonalizationWorkflowsAsyncWithHttpInfo
     *
     * Returns all available product personalization workflows.
     *
     * @param  int $skip Defines page start offset from beginning of sorted result list. (optional)
     * @param  int $take Defines page length (how many consequent items of sorted result list should be taken). (optional)
     * @param  string $search Search string for partial by personalization workflow name. (optional)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementGetAvailablePersonalizationWorkflows'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsManagementGetAvailablePersonalizationWorkflowsAsyncWithHttpInfo($skip = null, $take = null, $search = null, $tenant_id = null, string $contentType = self::contentTypes['productsManagementGetAvailablePersonalizationWorkflows'][0])
    {
        $returnType = '\Aurigma\BackOffice\Model\PagedOfPersonalizationWorkflowDto';
        $request = $this->productsManagementGetAvailablePersonalizationWorkflowsRequest($skip, $take, $search, $tenant_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsManagementGetAvailablePersonalizationWorkflows'
     *
     * @param  int $skip Defines page start offset from beginning of sorted result list. (optional)
     * @param  int $take Defines page length (how many consequent items of sorted result list should be taken). (optional)
     * @param  string $search Search string for partial by personalization workflow name. (optional)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementGetAvailablePersonalizationWorkflows'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsManagementGetAvailablePersonalizationWorkflowsRequest($skip = null, $take = null, $search = null, $tenant_id = null, string $contentType = self::contentTypes['productsManagementGetAvailablePersonalizationWorkflows'][0])
    {






        $resourcePath = '/api/backoffice/v1/products/available-workflows';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $skip,
            'skip', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $take,
            'take', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $search,
            'search', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_id,
            'tenantId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsManagementGetAvailableProcessingPipelines
     *
     * Returns all available product processing pipelines.
     *
     * @param  int $skip Defines page start offset from beginning of sorted result list. (optional)
     * @param  int $take Defines page length (how many consequent items of sorted result list should be taken). (optional)
     * @param  string $search Search string for partial by processing pipeline name. (optional)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementGetAvailableProcessingPipelines'] to see the possible values for this operation
     *
     * @throws \Aurigma\BackOffice\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Aurigma\BackOffice\Model\PagedOfProcessingPipelineDto
     */
    public function productsManagementGetAvailableProcessingPipelines($skip = null, $take = null, $search = null, $tenant_id = null, string $contentType = self::contentTypes['productsManagementGetAvailableProcessingPipelines'][0])
    {
        list($response) = $this->productsManagementGetAvailableProcessingPipelinesWithHttpInfo($skip, $take, $search, $tenant_id, $contentType);
        return $response;
    }

    /**
     * Operation productsManagementGetAvailableProcessingPipelinesWithHttpInfo
     *
     * Returns all available product processing pipelines.
     *
     * @param  int $skip Defines page start offset from beginning of sorted result list. (optional)
     * @param  int $take Defines page length (how many consequent items of sorted result list should be taken). (optional)
     * @param  string $search Search string for partial by processing pipeline name. (optional)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementGetAvailableProcessingPipelines'] to see the possible values for this operation
     *
     * @throws \Aurigma\BackOffice\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Aurigma\BackOffice\Model\PagedOfProcessingPipelineDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsManagementGetAvailableProcessingPipelinesWithHttpInfo($skip = null, $take = null, $search = null, $tenant_id = null, string $contentType = self::contentTypes['productsManagementGetAvailableProcessingPipelines'][0])
    {
        $request = $this->productsManagementGetAvailableProcessingPipelinesRequest($skip, $take, $search, $tenant_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Aurigma\BackOffice\Model\PagedOfProcessingPipelineDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Aurigma\BackOffice\Model\PagedOfProcessingPipelineDto' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Aurigma\BackOffice\Model\PagedOfProcessingPipelineDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Aurigma\BackOffice\Model\PagedOfProcessingPipelineDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurigma\BackOffice\Model\PagedOfProcessingPipelineDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsManagementGetAvailableProcessingPipelinesAsync
     *
     * Returns all available product processing pipelines.
     *
     * @param  int $skip Defines page start offset from beginning of sorted result list. (optional)
     * @param  int $take Defines page length (how many consequent items of sorted result list should be taken). (optional)
     * @param  string $search Search string for partial by processing pipeline name. (optional)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementGetAvailableProcessingPipelines'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsManagementGetAvailableProcessingPipelinesAsync($skip = null, $take = null, $search = null, $tenant_id = null, string $contentType = self::contentTypes['productsManagementGetAvailableProcessingPipelines'][0])
    {
        return $this->productsManagementGetAvailableProcessingPipelinesAsyncWithHttpInfo($skip, $take, $search, $tenant_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsManagementGetAvailableProcessingPipelinesAsyncWithHttpInfo
     *
     * Returns all available product processing pipelines.
     *
     * @param  int $skip Defines page start offset from beginning of sorted result list. (optional)
     * @param  int $take Defines page length (how many consequent items of sorted result list should be taken). (optional)
     * @param  string $search Search string for partial by processing pipeline name. (optional)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementGetAvailableProcessingPipelines'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsManagementGetAvailableProcessingPipelinesAsyncWithHttpInfo($skip = null, $take = null, $search = null, $tenant_id = null, string $contentType = self::contentTypes['productsManagementGetAvailableProcessingPipelines'][0])
    {
        $returnType = '\Aurigma\BackOffice\Model\PagedOfProcessingPipelineDto';
        $request = $this->productsManagementGetAvailableProcessingPipelinesRequest($skip, $take, $search, $tenant_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsManagementGetAvailableProcessingPipelines'
     *
     * @param  int $skip Defines page start offset from beginning of sorted result list. (optional)
     * @param  int $take Defines page length (how many consequent items of sorted result list should be taken). (optional)
     * @param  string $search Search string for partial by processing pipeline name. (optional)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementGetAvailableProcessingPipelines'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsManagementGetAvailableProcessingPipelinesRequest($skip = null, $take = null, $search = null, $tenant_id = null, string $contentType = self::contentTypes['productsManagementGetAvailableProcessingPipelines'][0])
    {






        $resourcePath = '/api/backoffice/v1/products/available-pipelines';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $skip,
            'skip', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $take,
            'take', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $search,
            'search', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_id,
            'tenantId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsManagementGetProduct
     *
     * Returns a product by its identifier.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $product_version_id Product version identifier. (optional)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementGetProduct'] to see the possible values for this operation
     *
     * @throws \Aurigma\BackOffice\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Aurigma\BackOffice\Model\ProductDto|\Aurigma\BackOffice\Model\MicrosoftAspNetCoreMvcProblemDetails|\Aurigma\BackOffice\Model\GeneralConflictDto
     */
    public function productsManagementGetProduct($id, $product_version_id = null, $tenant_id = null, string $contentType = self::contentTypes['productsManagementGetProduct'][0])
    {
        list($response) = $this->productsManagementGetProductWithHttpInfo($id, $product_version_id, $tenant_id, $contentType);
        return $response;
    }

    /**
     * Operation productsManagementGetProductWithHttpInfo
     *
     * Returns a product by its identifier.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $product_version_id Product version identifier. (optional)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementGetProduct'] to see the possible values for this operation
     *
     * @throws \Aurigma\BackOffice\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Aurigma\BackOffice\Model\ProductDto|\Aurigma\BackOffice\Model\MicrosoftAspNetCoreMvcProblemDetails|\Aurigma\BackOffice\Model\GeneralConflictDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsManagementGetProductWithHttpInfo($id, $product_version_id = null, $tenant_id = null, string $contentType = self::contentTypes['productsManagementGetProduct'][0])
    {
        $request = $this->productsManagementGetProductRequest($id, $product_version_id, $tenant_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Aurigma\BackOffice\Model\ProductDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Aurigma\BackOffice\Model\ProductDto' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Aurigma\BackOffice\Model\ProductDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\Aurigma\BackOffice\Model\MicrosoftAspNetCoreMvcProblemDetails' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Aurigma\BackOffice\Model\MicrosoftAspNetCoreMvcProblemDetails' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Aurigma\BackOffice\Model\MicrosoftAspNetCoreMvcProblemDetails', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\Aurigma\BackOffice\Model\GeneralConflictDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Aurigma\BackOffice\Model\GeneralConflictDto' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Aurigma\BackOffice\Model\GeneralConflictDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Aurigma\BackOffice\Model\ProductDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurigma\BackOffice\Model\ProductDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurigma\BackOffice\Model\MicrosoftAspNetCoreMvcProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurigma\BackOffice\Model\GeneralConflictDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsManagementGetProductAsync
     *
     * Returns a product by its identifier.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $product_version_id Product version identifier. (optional)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementGetProduct'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsManagementGetProductAsync($id, $product_version_id = null, $tenant_id = null, string $contentType = self::contentTypes['productsManagementGetProduct'][0])
    {
        return $this->productsManagementGetProductAsyncWithHttpInfo($id, $product_version_id, $tenant_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsManagementGetProductAsyncWithHttpInfo
     *
     * Returns a product by its identifier.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $product_version_id Product version identifier. (optional)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementGetProduct'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsManagementGetProductAsyncWithHttpInfo($id, $product_version_id = null, $tenant_id = null, string $contentType = self::contentTypes['productsManagementGetProduct'][0])
    {
        $returnType = '\Aurigma\BackOffice\Model\ProductDto';
        $request = $this->productsManagementGetProductRequest($id, $product_version_id, $tenant_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsManagementGetProduct'
     *
     * @param  int $id Product identifier. (required)
     * @param  int $product_version_id Product version identifier. (optional)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementGetProduct'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsManagementGetProductRequest($id, $product_version_id = null, $tenant_id = null, string $contentType = self::contentTypes['productsManagementGetProduct'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productsManagementGetProduct'
            );
        }




        $resourcePath = '/api/backoffice/v1/products/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $product_version_id,
            'productVersionId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_id,
            'tenantId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsManagementGetProductOptions
     *
     * Returns a list of product options.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $product_version_id Product version identifier. (optional)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementGetProductOptions'] to see the possible values for this operation
     *
     * @throws \Aurigma\BackOffice\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Aurigma\BackOffice\Model\PagedOfProductOptionDto|\Aurigma\BackOffice\Model\MicrosoftAspNetCoreMvcProblemDetails|\Aurigma\BackOffice\Model\GeneralConflictDto
     */
    public function productsManagementGetProductOptions($id, $product_version_id = null, $tenant_id = null, string $contentType = self::contentTypes['productsManagementGetProductOptions'][0])
    {
        list($response) = $this->productsManagementGetProductOptionsWithHttpInfo($id, $product_version_id, $tenant_id, $contentType);
        return $response;
    }

    /**
     * Operation productsManagementGetProductOptionsWithHttpInfo
     *
     * Returns a list of product options.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $product_version_id Product version identifier. (optional)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementGetProductOptions'] to see the possible values for this operation
     *
     * @throws \Aurigma\BackOffice\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Aurigma\BackOffice\Model\PagedOfProductOptionDto|\Aurigma\BackOffice\Model\MicrosoftAspNetCoreMvcProblemDetails|\Aurigma\BackOffice\Model\GeneralConflictDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsManagementGetProductOptionsWithHttpInfo($id, $product_version_id = null, $tenant_id = null, string $contentType = self::contentTypes['productsManagementGetProductOptions'][0])
    {
        $request = $this->productsManagementGetProductOptionsRequest($id, $product_version_id, $tenant_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Aurigma\BackOffice\Model\PagedOfProductOptionDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Aurigma\BackOffice\Model\PagedOfProductOptionDto' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Aurigma\BackOffice\Model\PagedOfProductOptionDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\Aurigma\BackOffice\Model\MicrosoftAspNetCoreMvcProblemDetails' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Aurigma\BackOffice\Model\MicrosoftAspNetCoreMvcProblemDetails' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Aurigma\BackOffice\Model\MicrosoftAspNetCoreMvcProblemDetails', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\Aurigma\BackOffice\Model\GeneralConflictDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Aurigma\BackOffice\Model\GeneralConflictDto' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Aurigma\BackOffice\Model\GeneralConflictDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Aurigma\BackOffice\Model\PagedOfProductOptionDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurigma\BackOffice\Model\PagedOfProductOptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurigma\BackOffice\Model\MicrosoftAspNetCoreMvcProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurigma\BackOffice\Model\GeneralConflictDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsManagementGetProductOptionsAsync
     *
     * Returns a list of product options.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $product_version_id Product version identifier. (optional)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementGetProductOptions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsManagementGetProductOptionsAsync($id, $product_version_id = null, $tenant_id = null, string $contentType = self::contentTypes['productsManagementGetProductOptions'][0])
    {
        return $this->productsManagementGetProductOptionsAsyncWithHttpInfo($id, $product_version_id, $tenant_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsManagementGetProductOptionsAsyncWithHttpInfo
     *
     * Returns a list of product options.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $product_version_id Product version identifier. (optional)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementGetProductOptions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsManagementGetProductOptionsAsyncWithHttpInfo($id, $product_version_id = null, $tenant_id = null, string $contentType = self::contentTypes['productsManagementGetProductOptions'][0])
    {
        $returnType = '\Aurigma\BackOffice\Model\PagedOfProductOptionDto';
        $request = $this->productsManagementGetProductOptionsRequest($id, $product_version_id, $tenant_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsManagementGetProductOptions'
     *
     * @param  int $id Product identifier. (required)
     * @param  int $product_version_id Product version identifier. (optional)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementGetProductOptions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsManagementGetProductOptionsRequest($id, $product_version_id = null, $tenant_id = null, string $contentType = self::contentTypes['productsManagementGetProductOptions'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productsManagementGetProductOptions'
            );
        }




        $resourcePath = '/api/backoffice/v1/products/{id}/options';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $product_version_id,
            'productVersionId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_id,
            'tenantId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsManagementGetProductVariant
     *
     * Returns a product variant.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $product_variant_id Product variant identifier. (required)
     * @param  int $product_version_id Product version identifier. (optional)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementGetProductVariant'] to see the possible values for this operation
     *
     * @throws \Aurigma\BackOffice\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Aurigma\BackOffice\Model\ProductVariantDto|\Aurigma\BackOffice\Model\MicrosoftAspNetCoreMvcProblemDetails|\Aurigma\BackOffice\Model\GeneralConflictDto
     */
    public function productsManagementGetProductVariant($id, $product_variant_id, $product_version_id = null, $tenant_id = null, string $contentType = self::contentTypes['productsManagementGetProductVariant'][0])
    {
        list($response) = $this->productsManagementGetProductVariantWithHttpInfo($id, $product_variant_id, $product_version_id, $tenant_id, $contentType);
        return $response;
    }

    /**
     * Operation productsManagementGetProductVariantWithHttpInfo
     *
     * Returns a product variant.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $product_variant_id Product variant identifier. (required)
     * @param  int $product_version_id Product version identifier. (optional)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementGetProductVariant'] to see the possible values for this operation
     *
     * @throws \Aurigma\BackOffice\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Aurigma\BackOffice\Model\ProductVariantDto|\Aurigma\BackOffice\Model\MicrosoftAspNetCoreMvcProblemDetails|\Aurigma\BackOffice\Model\GeneralConflictDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsManagementGetProductVariantWithHttpInfo($id, $product_variant_id, $product_version_id = null, $tenant_id = null, string $contentType = self::contentTypes['productsManagementGetProductVariant'][0])
    {
        $request = $this->productsManagementGetProductVariantRequest($id, $product_variant_id, $product_version_id, $tenant_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Aurigma\BackOffice\Model\ProductVariantDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Aurigma\BackOffice\Model\ProductVariantDto' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Aurigma\BackOffice\Model\ProductVariantDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\Aurigma\BackOffice\Model\MicrosoftAspNetCoreMvcProblemDetails' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Aurigma\BackOffice\Model\MicrosoftAspNetCoreMvcProblemDetails' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Aurigma\BackOffice\Model\MicrosoftAspNetCoreMvcProblemDetails', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\Aurigma\BackOffice\Model\GeneralConflictDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Aurigma\BackOffice\Model\GeneralConflictDto' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Aurigma\BackOffice\Model\GeneralConflictDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Aurigma\BackOffice\Model\ProductVariantDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurigma\BackOffice\Model\ProductVariantDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurigma\BackOffice\Model\MicrosoftAspNetCoreMvcProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurigma\BackOffice\Model\GeneralConflictDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsManagementGetProductVariantAsync
     *
     * Returns a product variant.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $product_variant_id Product variant identifier. (required)
     * @param  int $product_version_id Product version identifier. (optional)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementGetProductVariant'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsManagementGetProductVariantAsync($id, $product_variant_id, $product_version_id = null, $tenant_id = null, string $contentType = self::contentTypes['productsManagementGetProductVariant'][0])
    {
        return $this->productsManagementGetProductVariantAsyncWithHttpInfo($id, $product_variant_id, $product_version_id, $tenant_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsManagementGetProductVariantAsyncWithHttpInfo
     *
     * Returns a product variant.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $product_variant_id Product variant identifier. (required)
     * @param  int $product_version_id Product version identifier. (optional)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementGetProductVariant'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsManagementGetProductVariantAsyncWithHttpInfo($id, $product_variant_id, $product_version_id = null, $tenant_id = null, string $contentType = self::contentTypes['productsManagementGetProductVariant'][0])
    {
        $returnType = '\Aurigma\BackOffice\Model\ProductVariantDto';
        $request = $this->productsManagementGetProductVariantRequest($id, $product_variant_id, $product_version_id, $tenant_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsManagementGetProductVariant'
     *
     * @param  int $id Product identifier. (required)
     * @param  int $product_variant_id Product variant identifier. (required)
     * @param  int $product_version_id Product version identifier. (optional)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementGetProductVariant'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsManagementGetProductVariantRequest($id, $product_variant_id, $product_version_id = null, $tenant_id = null, string $contentType = self::contentTypes['productsManagementGetProductVariant'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productsManagementGetProductVariant'
            );
        }

        // verify the required parameter 'product_variant_id' is set
        if ($product_variant_id === null || (is_array($product_variant_id) && count($product_variant_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $product_variant_id when calling productsManagementGetProductVariant'
            );
        }




        $resourcePath = '/api/backoffice/v1/products/{id}/variants/{productVariantId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $product_version_id,
            'productVersionId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_id,
            'tenantId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($product_variant_id !== null) {
            $resourcePath = str_replace(
                '{' . 'productVariantId' . '}',
                ObjectSerializer::toPathValue($product_variant_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsManagementGetProductVariantDesigns
     *
     * Returns a list of product variant designs.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $product_version_id Product version identifier. (optional)
     * @param  int $product_variant_id Product variant identifier. (optional)
     * @param  string $search Search string for design name partial match. (optional)
     * @param  string $design_custom_fields Custom attributes dictionary filter for designs. For example: {\&quot;public\&quot;:\&quot;true\&quot;,\&quot;name\&quot;:\&quot;my item\&quot;} (optional)
     * @param  string $design_path Path filter for designs. Subfolders included by default. (optional)
     * @param  int $skip Defines page start offset from beginning of sorted result list. (optional)
     * @param  int $take Defines page length (how many consequent items of sorted result list should be taken). (optional)
     * @param  string $options Defines options filter e.g.: \&quot;{ \&quot;opt1_id\&quot;: \&quot;opt1_val1_id, opt1_val2_id\&quot;, \&quot;opt2_id\&quot;: \&quot;opt2_val1_id\&quot; }\&quot;. (optional)
     * @param  int $product_filter_id Defines special filter based on product filter with specified identifier. (optional)
     * @param  bool $take_available_only Defines special filter for available product variants. (optional)
     * @param  string $sku SKU of linked ecommerce product. (optional)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementGetProductVariantDesigns'] to see the possible values for this operation
     *
     * @throws \Aurigma\BackOffice\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Aurigma\BackOffice\Model\PagedOfProductVariantDesignDto|\Aurigma\BackOffice\Model\MicrosoftAspNetCoreMvcProblemDetails|\Aurigma\BackOffice\Model\GeneralConflictDto
     */
    public function productsManagementGetProductVariantDesigns($id, $product_version_id = null, $product_variant_id = null, $search = null, $design_custom_fields = null, $design_path = null, $skip = null, $take = null, $options = null, $product_filter_id = null, $take_available_only = null, $sku = null, $tenant_id = null, string $contentType = self::contentTypes['productsManagementGetProductVariantDesigns'][0])
    {
        list($response) = $this->productsManagementGetProductVariantDesignsWithHttpInfo($id, $product_version_id, $product_variant_id, $search, $design_custom_fields, $design_path, $skip, $take, $options, $product_filter_id, $take_available_only, $sku, $tenant_id, $contentType);
        return $response;
    }

    /**
     * Operation productsManagementGetProductVariantDesignsWithHttpInfo
     *
     * Returns a list of product variant designs.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $product_version_id Product version identifier. (optional)
     * @param  int $product_variant_id Product variant identifier. (optional)
     * @param  string $search Search string for design name partial match. (optional)
     * @param  string $design_custom_fields Custom attributes dictionary filter for designs. For example: {\&quot;public\&quot;:\&quot;true\&quot;,\&quot;name\&quot;:\&quot;my item\&quot;} (optional)
     * @param  string $design_path Path filter for designs. Subfolders included by default. (optional)
     * @param  int $skip Defines page start offset from beginning of sorted result list. (optional)
     * @param  int $take Defines page length (how many consequent items of sorted result list should be taken). (optional)
     * @param  string $options Defines options filter e.g.: \&quot;{ \&quot;opt1_id\&quot;: \&quot;opt1_val1_id, opt1_val2_id\&quot;, \&quot;opt2_id\&quot;: \&quot;opt2_val1_id\&quot; }\&quot;. (optional)
     * @param  int $product_filter_id Defines special filter based on product filter with specified identifier. (optional)
     * @param  bool $take_available_only Defines special filter for available product variants. (optional)
     * @param  string $sku SKU of linked ecommerce product. (optional)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementGetProductVariantDesigns'] to see the possible values for this operation
     *
     * @throws \Aurigma\BackOffice\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Aurigma\BackOffice\Model\PagedOfProductVariantDesignDto|\Aurigma\BackOffice\Model\MicrosoftAspNetCoreMvcProblemDetails|\Aurigma\BackOffice\Model\GeneralConflictDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsManagementGetProductVariantDesignsWithHttpInfo($id, $product_version_id = null, $product_variant_id = null, $search = null, $design_custom_fields = null, $design_path = null, $skip = null, $take = null, $options = null, $product_filter_id = null, $take_available_only = null, $sku = null, $tenant_id = null, string $contentType = self::contentTypes['productsManagementGetProductVariantDesigns'][0])
    {
        $request = $this->productsManagementGetProductVariantDesignsRequest($id, $product_version_id, $product_variant_id, $search, $design_custom_fields, $design_path, $skip, $take, $options, $product_filter_id, $take_available_only, $sku, $tenant_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Aurigma\BackOffice\Model\PagedOfProductVariantDesignDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Aurigma\BackOffice\Model\PagedOfProductVariantDesignDto' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Aurigma\BackOffice\Model\PagedOfProductVariantDesignDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\Aurigma\BackOffice\Model\MicrosoftAspNetCoreMvcProblemDetails' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Aurigma\BackOffice\Model\MicrosoftAspNetCoreMvcProblemDetails' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Aurigma\BackOffice\Model\MicrosoftAspNetCoreMvcProblemDetails', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\Aurigma\BackOffice\Model\GeneralConflictDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Aurigma\BackOffice\Model\GeneralConflictDto' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Aurigma\BackOffice\Model\GeneralConflictDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Aurigma\BackOffice\Model\PagedOfProductVariantDesignDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurigma\BackOffice\Model\PagedOfProductVariantDesignDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurigma\BackOffice\Model\MicrosoftAspNetCoreMvcProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurigma\BackOffice\Model\GeneralConflictDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsManagementGetProductVariantDesignsAsync
     *
     * Returns a list of product variant designs.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $product_version_id Product version identifier. (optional)
     * @param  int $product_variant_id Product variant identifier. (optional)
     * @param  string $search Search string for design name partial match. (optional)
     * @param  string $design_custom_fields Custom attributes dictionary filter for designs. For example: {\&quot;public\&quot;:\&quot;true\&quot;,\&quot;name\&quot;:\&quot;my item\&quot;} (optional)
     * @param  string $design_path Path filter for designs. Subfolders included by default. (optional)
     * @param  int $skip Defines page start offset from beginning of sorted result list. (optional)
     * @param  int $take Defines page length (how many consequent items of sorted result list should be taken). (optional)
     * @param  string $options Defines options filter e.g.: \&quot;{ \&quot;opt1_id\&quot;: \&quot;opt1_val1_id, opt1_val2_id\&quot;, \&quot;opt2_id\&quot;: \&quot;opt2_val1_id\&quot; }\&quot;. (optional)
     * @param  int $product_filter_id Defines special filter based on product filter with specified identifier. (optional)
     * @param  bool $take_available_only Defines special filter for available product variants. (optional)
     * @param  string $sku SKU of linked ecommerce product. (optional)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementGetProductVariantDesigns'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsManagementGetProductVariantDesignsAsync($id, $product_version_id = null, $product_variant_id = null, $search = null, $design_custom_fields = null, $design_path = null, $skip = null, $take = null, $options = null, $product_filter_id = null, $take_available_only = null, $sku = null, $tenant_id = null, string $contentType = self::contentTypes['productsManagementGetProductVariantDesigns'][0])
    {
        return $this->productsManagementGetProductVariantDesignsAsyncWithHttpInfo($id, $product_version_id, $product_variant_id, $search, $design_custom_fields, $design_path, $skip, $take, $options, $product_filter_id, $take_available_only, $sku, $tenant_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsManagementGetProductVariantDesignsAsyncWithHttpInfo
     *
     * Returns a list of product variant designs.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $product_version_id Product version identifier. (optional)
     * @param  int $product_variant_id Product variant identifier. (optional)
     * @param  string $search Search string for design name partial match. (optional)
     * @param  string $design_custom_fields Custom attributes dictionary filter for designs. For example: {\&quot;public\&quot;:\&quot;true\&quot;,\&quot;name\&quot;:\&quot;my item\&quot;} (optional)
     * @param  string $design_path Path filter for designs. Subfolders included by default. (optional)
     * @param  int $skip Defines page start offset from beginning of sorted result list. (optional)
     * @param  int $take Defines page length (how many consequent items of sorted result list should be taken). (optional)
     * @param  string $options Defines options filter e.g.: \&quot;{ \&quot;opt1_id\&quot;: \&quot;opt1_val1_id, opt1_val2_id\&quot;, \&quot;opt2_id\&quot;: \&quot;opt2_val1_id\&quot; }\&quot;. (optional)
     * @param  int $product_filter_id Defines special filter based on product filter with specified identifier. (optional)
     * @param  bool $take_available_only Defines special filter for available product variants. (optional)
     * @param  string $sku SKU of linked ecommerce product. (optional)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementGetProductVariantDesigns'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsManagementGetProductVariantDesignsAsyncWithHttpInfo($id, $product_version_id = null, $product_variant_id = null, $search = null, $design_custom_fields = null, $design_path = null, $skip = null, $take = null, $options = null, $product_filter_id = null, $take_available_only = null, $sku = null, $tenant_id = null, string $contentType = self::contentTypes['productsManagementGetProductVariantDesigns'][0])
    {
        $returnType = '\Aurigma\BackOffice\Model\PagedOfProductVariantDesignDto';
        $request = $this->productsManagementGetProductVariantDesignsRequest($id, $product_version_id, $product_variant_id, $search, $design_custom_fields, $design_path, $skip, $take, $options, $product_filter_id, $take_available_only, $sku, $tenant_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsManagementGetProductVariantDesigns'
     *
     * @param  int $id Product identifier. (required)
     * @param  int $product_version_id Product version identifier. (optional)
     * @param  int $product_variant_id Product variant identifier. (optional)
     * @param  string $search Search string for design name partial match. (optional)
     * @param  string $design_custom_fields Custom attributes dictionary filter for designs. For example: {\&quot;public\&quot;:\&quot;true\&quot;,\&quot;name\&quot;:\&quot;my item\&quot;} (optional)
     * @param  string $design_path Path filter for designs. Subfolders included by default. (optional)
     * @param  int $skip Defines page start offset from beginning of sorted result list. (optional)
     * @param  int $take Defines page length (how many consequent items of sorted result list should be taken). (optional)
     * @param  string $options Defines options filter e.g.: \&quot;{ \&quot;opt1_id\&quot;: \&quot;opt1_val1_id, opt1_val2_id\&quot;, \&quot;opt2_id\&quot;: \&quot;opt2_val1_id\&quot; }\&quot;. (optional)
     * @param  int $product_filter_id Defines special filter based on product filter with specified identifier. (optional)
     * @param  bool $take_available_only Defines special filter for available product variants. (optional)
     * @param  string $sku SKU of linked ecommerce product. (optional)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementGetProductVariantDesigns'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsManagementGetProductVariantDesignsRequest($id, $product_version_id = null, $product_variant_id = null, $search = null, $design_custom_fields = null, $design_path = null, $skip = null, $take = null, $options = null, $product_filter_id = null, $take_available_only = null, $sku = null, $tenant_id = null, string $contentType = self::contentTypes['productsManagementGetProductVariantDesigns'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productsManagementGetProductVariantDesigns'
            );
        }














        $resourcePath = '/api/backoffice/v1/products/{id}/variant-designs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $product_version_id,
            'productVersionId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $product_variant_id,
            'productVariantId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $search,
            'search', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $design_custom_fields,
            'designCustomFields', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $design_path,
            'designPath', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $skip,
            'skip', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $take,
            'take', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $options,
            'options', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $product_filter_id,
            'productFilterId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $take_available_only,
            'takeAvailableOnly', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sku,
            'sku', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_id,
            'tenantId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsManagementGetProductVariantDocuments
     *
     * Returns a list of product variant documents.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $product_version_id Product version identifier. (optional)
     * @param  int $product_variant_id Product variant identifier. (optional)
     * @param  string $search Search string for document name partial match. (optional)
     * @param  string $document_custom_fields Custom attributes dictionary filter for documents. For example: {\&quot;public\&quot;:\&quot;true\&quot;,\&quot;name\&quot;:\&quot;my item\&quot;} (optional)
     * @param  string $document_path Path filter for documents. Subfolders included by default. (optional)
     * @param  int $skip Defines page start offset from beginning of sorted result list. (optional)
     * @param  int $take Defines page length (how many consequent items of sorted result list should be taken). (optional)
     * @param  string $options Defines options filter e.g.: \&quot;{ \&quot;opt1_id\&quot;: \&quot;opt1_val1_id, opt1_val2_id\&quot;, \&quot;opt2_id\&quot;: \&quot;opt2_val1_id\&quot; }\&quot;. (optional)
     * @param  int $product_filter_id Defines special filter based on product filter with specified identifier. (optional)
     * @param  bool $take_available_only Defines special filter for available product variants. (optional)
     * @param  string $sku SKU of linked ecommerce product. (optional)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementGetProductVariantDocuments'] to see the possible values for this operation
     *
     * @throws \Aurigma\BackOffice\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Aurigma\BackOffice\Model\PagedOfProductVariantDocumentDto|\Aurigma\BackOffice\Model\MicrosoftAspNetCoreMvcProblemDetails|\Aurigma\BackOffice\Model\GeneralConflictDto
     */
    public function productsManagementGetProductVariantDocuments($id, $product_version_id = null, $product_variant_id = null, $search = null, $document_custom_fields = null, $document_path = null, $skip = null, $take = null, $options = null, $product_filter_id = null, $take_available_only = null, $sku = null, $tenant_id = null, string $contentType = self::contentTypes['productsManagementGetProductVariantDocuments'][0])
    {
        list($response) = $this->productsManagementGetProductVariantDocumentsWithHttpInfo($id, $product_version_id, $product_variant_id, $search, $document_custom_fields, $document_path, $skip, $take, $options, $product_filter_id, $take_available_only, $sku, $tenant_id, $contentType);
        return $response;
    }

    /**
     * Operation productsManagementGetProductVariantDocumentsWithHttpInfo
     *
     * Returns a list of product variant documents.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $product_version_id Product version identifier. (optional)
     * @param  int $product_variant_id Product variant identifier. (optional)
     * @param  string $search Search string for document name partial match. (optional)
     * @param  string $document_custom_fields Custom attributes dictionary filter for documents. For example: {\&quot;public\&quot;:\&quot;true\&quot;,\&quot;name\&quot;:\&quot;my item\&quot;} (optional)
     * @param  string $document_path Path filter for documents. Subfolders included by default. (optional)
     * @param  int $skip Defines page start offset from beginning of sorted result list. (optional)
     * @param  int $take Defines page length (how many consequent items of sorted result list should be taken). (optional)
     * @param  string $options Defines options filter e.g.: \&quot;{ \&quot;opt1_id\&quot;: \&quot;opt1_val1_id, opt1_val2_id\&quot;, \&quot;opt2_id\&quot;: \&quot;opt2_val1_id\&quot; }\&quot;. (optional)
     * @param  int $product_filter_id Defines special filter based on product filter with specified identifier. (optional)
     * @param  bool $take_available_only Defines special filter for available product variants. (optional)
     * @param  string $sku SKU of linked ecommerce product. (optional)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementGetProductVariantDocuments'] to see the possible values for this operation
     *
     * @throws \Aurigma\BackOffice\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Aurigma\BackOffice\Model\PagedOfProductVariantDocumentDto|\Aurigma\BackOffice\Model\MicrosoftAspNetCoreMvcProblemDetails|\Aurigma\BackOffice\Model\GeneralConflictDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsManagementGetProductVariantDocumentsWithHttpInfo($id, $product_version_id = null, $product_variant_id = null, $search = null, $document_custom_fields = null, $document_path = null, $skip = null, $take = null, $options = null, $product_filter_id = null, $take_available_only = null, $sku = null, $tenant_id = null, string $contentType = self::contentTypes['productsManagementGetProductVariantDocuments'][0])
    {
        $request = $this->productsManagementGetProductVariantDocumentsRequest($id, $product_version_id, $product_variant_id, $search, $document_custom_fields, $document_path, $skip, $take, $options, $product_filter_id, $take_available_only, $sku, $tenant_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Aurigma\BackOffice\Model\PagedOfProductVariantDocumentDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Aurigma\BackOffice\Model\PagedOfProductVariantDocumentDto' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Aurigma\BackOffice\Model\PagedOfProductVariantDocumentDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\Aurigma\BackOffice\Model\MicrosoftAspNetCoreMvcProblemDetails' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Aurigma\BackOffice\Model\MicrosoftAspNetCoreMvcProblemDetails' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Aurigma\BackOffice\Model\MicrosoftAspNetCoreMvcProblemDetails', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\Aurigma\BackOffice\Model\GeneralConflictDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Aurigma\BackOffice\Model\GeneralConflictDto' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Aurigma\BackOffice\Model\GeneralConflictDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Aurigma\BackOffice\Model\PagedOfProductVariantDocumentDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurigma\BackOffice\Model\PagedOfProductVariantDocumentDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurigma\BackOffice\Model\MicrosoftAspNetCoreMvcProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurigma\BackOffice\Model\GeneralConflictDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsManagementGetProductVariantDocumentsAsync
     *
     * Returns a list of product variant documents.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $product_version_id Product version identifier. (optional)
     * @param  int $product_variant_id Product variant identifier. (optional)
     * @param  string $search Search string for document name partial match. (optional)
     * @param  string $document_custom_fields Custom attributes dictionary filter for documents. For example: {\&quot;public\&quot;:\&quot;true\&quot;,\&quot;name\&quot;:\&quot;my item\&quot;} (optional)
     * @param  string $document_path Path filter for documents. Subfolders included by default. (optional)
     * @param  int $skip Defines page start offset from beginning of sorted result list. (optional)
     * @param  int $take Defines page length (how many consequent items of sorted result list should be taken). (optional)
     * @param  string $options Defines options filter e.g.: \&quot;{ \&quot;opt1_id\&quot;: \&quot;opt1_val1_id, opt1_val2_id\&quot;, \&quot;opt2_id\&quot;: \&quot;opt2_val1_id\&quot; }\&quot;. (optional)
     * @param  int $product_filter_id Defines special filter based on product filter with specified identifier. (optional)
     * @param  bool $take_available_only Defines special filter for available product variants. (optional)
     * @param  string $sku SKU of linked ecommerce product. (optional)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementGetProductVariantDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsManagementGetProductVariantDocumentsAsync($id, $product_version_id = null, $product_variant_id = null, $search = null, $document_custom_fields = null, $document_path = null, $skip = null, $take = null, $options = null, $product_filter_id = null, $take_available_only = null, $sku = null, $tenant_id = null, string $contentType = self::contentTypes['productsManagementGetProductVariantDocuments'][0])
    {
        return $this->productsManagementGetProductVariantDocumentsAsyncWithHttpInfo($id, $product_version_id, $product_variant_id, $search, $document_custom_fields, $document_path, $skip, $take, $options, $product_filter_id, $take_available_only, $sku, $tenant_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsManagementGetProductVariantDocumentsAsyncWithHttpInfo
     *
     * Returns a list of product variant documents.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $product_version_id Product version identifier. (optional)
     * @param  int $product_variant_id Product variant identifier. (optional)
     * @param  string $search Search string for document name partial match. (optional)
     * @param  string $document_custom_fields Custom attributes dictionary filter for documents. For example: {\&quot;public\&quot;:\&quot;true\&quot;,\&quot;name\&quot;:\&quot;my item\&quot;} (optional)
     * @param  string $document_path Path filter for documents. Subfolders included by default. (optional)
     * @param  int $skip Defines page start offset from beginning of sorted result list. (optional)
     * @param  int $take Defines page length (how many consequent items of sorted result list should be taken). (optional)
     * @param  string $options Defines options filter e.g.: \&quot;{ \&quot;opt1_id\&quot;: \&quot;opt1_val1_id, opt1_val2_id\&quot;, \&quot;opt2_id\&quot;: \&quot;opt2_val1_id\&quot; }\&quot;. (optional)
     * @param  int $product_filter_id Defines special filter based on product filter with specified identifier. (optional)
     * @param  bool $take_available_only Defines special filter for available product variants. (optional)
     * @param  string $sku SKU of linked ecommerce product. (optional)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementGetProductVariantDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsManagementGetProductVariantDocumentsAsyncWithHttpInfo($id, $product_version_id = null, $product_variant_id = null, $search = null, $document_custom_fields = null, $document_path = null, $skip = null, $take = null, $options = null, $product_filter_id = null, $take_available_only = null, $sku = null, $tenant_id = null, string $contentType = self::contentTypes['productsManagementGetProductVariantDocuments'][0])
    {
        $returnType = '\Aurigma\BackOffice\Model\PagedOfProductVariantDocumentDto';
        $request = $this->productsManagementGetProductVariantDocumentsRequest($id, $product_version_id, $product_variant_id, $search, $document_custom_fields, $document_path, $skip, $take, $options, $product_filter_id, $take_available_only, $sku, $tenant_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsManagementGetProductVariantDocuments'
     *
     * @param  int $id Product identifier. (required)
     * @param  int $product_version_id Product version identifier. (optional)
     * @param  int $product_variant_id Product variant identifier. (optional)
     * @param  string $search Search string for document name partial match. (optional)
     * @param  string $document_custom_fields Custom attributes dictionary filter for documents. For example: {\&quot;public\&quot;:\&quot;true\&quot;,\&quot;name\&quot;:\&quot;my item\&quot;} (optional)
     * @param  string $document_path Path filter for documents. Subfolders included by default. (optional)
     * @param  int $skip Defines page start offset from beginning of sorted result list. (optional)
     * @param  int $take Defines page length (how many consequent items of sorted result list should be taken). (optional)
     * @param  string $options Defines options filter e.g.: \&quot;{ \&quot;opt1_id\&quot;: \&quot;opt1_val1_id, opt1_val2_id\&quot;, \&quot;opt2_id\&quot;: \&quot;opt2_val1_id\&quot; }\&quot;. (optional)
     * @param  int $product_filter_id Defines special filter based on product filter with specified identifier. (optional)
     * @param  bool $take_available_only Defines special filter for available product variants. (optional)
     * @param  string $sku SKU of linked ecommerce product. (optional)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementGetProductVariantDocuments'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsManagementGetProductVariantDocumentsRequest($id, $product_version_id = null, $product_variant_id = null, $search = null, $document_custom_fields = null, $document_path = null, $skip = null, $take = null, $options = null, $product_filter_id = null, $take_available_only = null, $sku = null, $tenant_id = null, string $contentType = self::contentTypes['productsManagementGetProductVariantDocuments'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productsManagementGetProductVariantDocuments'
            );
        }














        $resourcePath = '/api/backoffice/v1/products/{id}/variant-documents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $product_version_id,
            'productVersionId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $product_variant_id,
            'productVariantId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $search,
            'search', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $document_custom_fields,
            'documentCustomFields', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $document_path,
            'documentPath', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $skip,
            'skip', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $take,
            'take', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $options,
            'options', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $product_filter_id,
            'productFilterId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $take_available_only,
            'takeAvailableOnly', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sku,
            'sku', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_id,
            'tenantId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsManagementGetProductVariantMockups
     *
     * Returns a list of product variant mockups.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $product_version_id Product version identifier. (optional)
     * @param  int $product_variant_id Product variant identifier. (optional)
     * @param  string $search Search string for design name partial match. (optional)
     * @param  string $mockup_custom_fields Custom attributes dictionary filter for mockups. For example: {\&quot;public\&quot;:\&quot;true\&quot;,\&quot;name\&quot;:\&quot;my item\&quot;} (optional)
     * @param  string $mockup_path Path filter for mockups. Subfolders included by default. (optional)
     * @param  int $skip Defines page start offset from beginning of sorted result list. (optional)
     * @param  int $take Defines page length (how many consequent items of sorted result list should be taken). (optional)
     * @param  string $options Defines options filter e.g.: \&quot;{ \&quot;opt1_id\&quot;: \&quot;opt1_val1_id, opt1_val2_id\&quot;, \&quot;opt2_id\&quot;: \&quot;opt2_val1_id\&quot; }\&quot;. (optional)
     * @param  int $product_filter_id Defines special filter based on product filter with specified identifier. (optional)
     * @param  bool $take_available_only Defines special filter for available product variants. (optional)
     * @param  string $sku SKU of linked ecommerce product. (optional)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementGetProductVariantMockups'] to see the possible values for this operation
     *
     * @throws \Aurigma\BackOffice\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Aurigma\BackOffice\Model\PagedOfProductVariantMockupDto|\Aurigma\BackOffice\Model\MicrosoftAspNetCoreMvcProblemDetails|\Aurigma\BackOffice\Model\GeneralConflictDto
     */
    public function productsManagementGetProductVariantMockups($id, $product_version_id = null, $product_variant_id = null, $search = null, $mockup_custom_fields = null, $mockup_path = null, $skip = null, $take = null, $options = null, $product_filter_id = null, $take_available_only = null, $sku = null, $tenant_id = null, string $contentType = self::contentTypes['productsManagementGetProductVariantMockups'][0])
    {
        list($response) = $this->productsManagementGetProductVariantMockupsWithHttpInfo($id, $product_version_id, $product_variant_id, $search, $mockup_custom_fields, $mockup_path, $skip, $take, $options, $product_filter_id, $take_available_only, $sku, $tenant_id, $contentType);
        return $response;
    }

    /**
     * Operation productsManagementGetProductVariantMockupsWithHttpInfo
     *
     * Returns a list of product variant mockups.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $product_version_id Product version identifier. (optional)
     * @param  int $product_variant_id Product variant identifier. (optional)
     * @param  string $search Search string for design name partial match. (optional)
     * @param  string $mockup_custom_fields Custom attributes dictionary filter for mockups. For example: {\&quot;public\&quot;:\&quot;true\&quot;,\&quot;name\&quot;:\&quot;my item\&quot;} (optional)
     * @param  string $mockup_path Path filter for mockups. Subfolders included by default. (optional)
     * @param  int $skip Defines page start offset from beginning of sorted result list. (optional)
     * @param  int $take Defines page length (how many consequent items of sorted result list should be taken). (optional)
     * @param  string $options Defines options filter e.g.: \&quot;{ \&quot;opt1_id\&quot;: \&quot;opt1_val1_id, opt1_val2_id\&quot;, \&quot;opt2_id\&quot;: \&quot;opt2_val1_id\&quot; }\&quot;. (optional)
     * @param  int $product_filter_id Defines special filter based on product filter with specified identifier. (optional)
     * @param  bool $take_available_only Defines special filter for available product variants. (optional)
     * @param  string $sku SKU of linked ecommerce product. (optional)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementGetProductVariantMockups'] to see the possible values for this operation
     *
     * @throws \Aurigma\BackOffice\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Aurigma\BackOffice\Model\PagedOfProductVariantMockupDto|\Aurigma\BackOffice\Model\MicrosoftAspNetCoreMvcProblemDetails|\Aurigma\BackOffice\Model\GeneralConflictDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsManagementGetProductVariantMockupsWithHttpInfo($id, $product_version_id = null, $product_variant_id = null, $search = null, $mockup_custom_fields = null, $mockup_path = null, $skip = null, $take = null, $options = null, $product_filter_id = null, $take_available_only = null, $sku = null, $tenant_id = null, string $contentType = self::contentTypes['productsManagementGetProductVariantMockups'][0])
    {
        $request = $this->productsManagementGetProductVariantMockupsRequest($id, $product_version_id, $product_variant_id, $search, $mockup_custom_fields, $mockup_path, $skip, $take, $options, $product_filter_id, $take_available_only, $sku, $tenant_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Aurigma\BackOffice\Model\PagedOfProductVariantMockupDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Aurigma\BackOffice\Model\PagedOfProductVariantMockupDto' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Aurigma\BackOffice\Model\PagedOfProductVariantMockupDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\Aurigma\BackOffice\Model\MicrosoftAspNetCoreMvcProblemDetails' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Aurigma\BackOffice\Model\MicrosoftAspNetCoreMvcProblemDetails' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Aurigma\BackOffice\Model\MicrosoftAspNetCoreMvcProblemDetails', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\Aurigma\BackOffice\Model\GeneralConflictDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Aurigma\BackOffice\Model\GeneralConflictDto' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Aurigma\BackOffice\Model\GeneralConflictDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Aurigma\BackOffice\Model\PagedOfProductVariantMockupDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurigma\BackOffice\Model\PagedOfProductVariantMockupDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurigma\BackOffice\Model\MicrosoftAspNetCoreMvcProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurigma\BackOffice\Model\GeneralConflictDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsManagementGetProductVariantMockupsAsync
     *
     * Returns a list of product variant mockups.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $product_version_id Product version identifier. (optional)
     * @param  int $product_variant_id Product variant identifier. (optional)
     * @param  string $search Search string for design name partial match. (optional)
     * @param  string $mockup_custom_fields Custom attributes dictionary filter for mockups. For example: {\&quot;public\&quot;:\&quot;true\&quot;,\&quot;name\&quot;:\&quot;my item\&quot;} (optional)
     * @param  string $mockup_path Path filter for mockups. Subfolders included by default. (optional)
     * @param  int $skip Defines page start offset from beginning of sorted result list. (optional)
     * @param  int $take Defines page length (how many consequent items of sorted result list should be taken). (optional)
     * @param  string $options Defines options filter e.g.: \&quot;{ \&quot;opt1_id\&quot;: \&quot;opt1_val1_id, opt1_val2_id\&quot;, \&quot;opt2_id\&quot;: \&quot;opt2_val1_id\&quot; }\&quot;. (optional)
     * @param  int $product_filter_id Defines special filter based on product filter with specified identifier. (optional)
     * @param  bool $take_available_only Defines special filter for available product variants. (optional)
     * @param  string $sku SKU of linked ecommerce product. (optional)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementGetProductVariantMockups'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsManagementGetProductVariantMockupsAsync($id, $product_version_id = null, $product_variant_id = null, $search = null, $mockup_custom_fields = null, $mockup_path = null, $skip = null, $take = null, $options = null, $product_filter_id = null, $take_available_only = null, $sku = null, $tenant_id = null, string $contentType = self::contentTypes['productsManagementGetProductVariantMockups'][0])
    {
        return $this->productsManagementGetProductVariantMockupsAsyncWithHttpInfo($id, $product_version_id, $product_variant_id, $search, $mockup_custom_fields, $mockup_path, $skip, $take, $options, $product_filter_id, $take_available_only, $sku, $tenant_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsManagementGetProductVariantMockupsAsyncWithHttpInfo
     *
     * Returns a list of product variant mockups.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $product_version_id Product version identifier. (optional)
     * @param  int $product_variant_id Product variant identifier. (optional)
     * @param  string $search Search string for design name partial match. (optional)
     * @param  string $mockup_custom_fields Custom attributes dictionary filter for mockups. For example: {\&quot;public\&quot;:\&quot;true\&quot;,\&quot;name\&quot;:\&quot;my item\&quot;} (optional)
     * @param  string $mockup_path Path filter for mockups. Subfolders included by default. (optional)
     * @param  int $skip Defines page start offset from beginning of sorted result list. (optional)
     * @param  int $take Defines page length (how many consequent items of sorted result list should be taken). (optional)
     * @param  string $options Defines options filter e.g.: \&quot;{ \&quot;opt1_id\&quot;: \&quot;opt1_val1_id, opt1_val2_id\&quot;, \&quot;opt2_id\&quot;: \&quot;opt2_val1_id\&quot; }\&quot;. (optional)
     * @param  int $product_filter_id Defines special filter based on product filter with specified identifier. (optional)
     * @param  bool $take_available_only Defines special filter for available product variants. (optional)
     * @param  string $sku SKU of linked ecommerce product. (optional)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementGetProductVariantMockups'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsManagementGetProductVariantMockupsAsyncWithHttpInfo($id, $product_version_id = null, $product_variant_id = null, $search = null, $mockup_custom_fields = null, $mockup_path = null, $skip = null, $take = null, $options = null, $product_filter_id = null, $take_available_only = null, $sku = null, $tenant_id = null, string $contentType = self::contentTypes['productsManagementGetProductVariantMockups'][0])
    {
        $returnType = '\Aurigma\BackOffice\Model\PagedOfProductVariantMockupDto';
        $request = $this->productsManagementGetProductVariantMockupsRequest($id, $product_version_id, $product_variant_id, $search, $mockup_custom_fields, $mockup_path, $skip, $take, $options, $product_filter_id, $take_available_only, $sku, $tenant_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsManagementGetProductVariantMockups'
     *
     * @param  int $id Product identifier. (required)
     * @param  int $product_version_id Product version identifier. (optional)
     * @param  int $product_variant_id Product variant identifier. (optional)
     * @param  string $search Search string for design name partial match. (optional)
     * @param  string $mockup_custom_fields Custom attributes dictionary filter for mockups. For example: {\&quot;public\&quot;:\&quot;true\&quot;,\&quot;name\&quot;:\&quot;my item\&quot;} (optional)
     * @param  string $mockup_path Path filter for mockups. Subfolders included by default. (optional)
     * @param  int $skip Defines page start offset from beginning of sorted result list. (optional)
     * @param  int $take Defines page length (how many consequent items of sorted result list should be taken). (optional)
     * @param  string $options Defines options filter e.g.: \&quot;{ \&quot;opt1_id\&quot;: \&quot;opt1_val1_id, opt1_val2_id\&quot;, \&quot;opt2_id\&quot;: \&quot;opt2_val1_id\&quot; }\&quot;. (optional)
     * @param  int $product_filter_id Defines special filter based on product filter with specified identifier. (optional)
     * @param  bool $take_available_only Defines special filter for available product variants. (optional)
     * @param  string $sku SKU of linked ecommerce product. (optional)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementGetProductVariantMockups'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsManagementGetProductVariantMockupsRequest($id, $product_version_id = null, $product_variant_id = null, $search = null, $mockup_custom_fields = null, $mockup_path = null, $skip = null, $take = null, $options = null, $product_filter_id = null, $take_available_only = null, $sku = null, $tenant_id = null, string $contentType = self::contentTypes['productsManagementGetProductVariantMockups'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productsManagementGetProductVariantMockups'
            );
        }














        $resourcePath = '/api/backoffice/v1/products/{id}/variant-mockups';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $product_version_id,
            'productVersionId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $product_variant_id,
            'productVariantId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $search,
            'search', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $mockup_custom_fields,
            'mockupCustomFields', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $mockup_path,
            'mockupPath', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $skip,
            'skip', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $take,
            'take', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $options,
            'options', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $product_filter_id,
            'productFilterId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $take_available_only,
            'takeAvailableOnly', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sku,
            'sku', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_id,
            'tenantId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsManagementGetProductVariants
     *
     * Returns a list of product variants.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $product_version_id Product version identifier. (optional)
     * @param  int $skip Defines page start offset from beginning of sorted result list. (optional)
     * @param  int $take Defines page length (how many consequent items of sorted result list should be taken). (optional)
     * @param  string $options Defines options filter e.g.: \&quot;{ \&quot;opt1_id\&quot;: \&quot;opt1_val1_id, opt1_val2_id\&quot;, \&quot;opt2_id\&quot;: \&quot;opt2_val1_id\&quot; }\&quot;. (optional)
     * @param  int $product_filter_id Defines special filter based on product filter with specified identifier. (optional)
     * @param  bool $take_available_only Defines special filter for available product variants. (optional)
     * @param  string $sku SKU of linked ecommerce product. (optional)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementGetProductVariants'] to see the possible values for this operation
     *
     * @throws \Aurigma\BackOffice\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Aurigma\BackOffice\Model\PagedOfProductVariantDto|\Aurigma\BackOffice\Model\MicrosoftAspNetCoreMvcProblemDetails|\Aurigma\BackOffice\Model\GeneralConflictDto
     */
    public function productsManagementGetProductVariants($id, $product_version_id = null, $skip = null, $take = null, $options = null, $product_filter_id = null, $take_available_only = null, $sku = null, $tenant_id = null, string $contentType = self::contentTypes['productsManagementGetProductVariants'][0])
    {
        list($response) = $this->productsManagementGetProductVariantsWithHttpInfo($id, $product_version_id, $skip, $take, $options, $product_filter_id, $take_available_only, $sku, $tenant_id, $contentType);
        return $response;
    }

    /**
     * Operation productsManagementGetProductVariantsWithHttpInfo
     *
     * Returns a list of product variants.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $product_version_id Product version identifier. (optional)
     * @param  int $skip Defines page start offset from beginning of sorted result list. (optional)
     * @param  int $take Defines page length (how many consequent items of sorted result list should be taken). (optional)
     * @param  string $options Defines options filter e.g.: \&quot;{ \&quot;opt1_id\&quot;: \&quot;opt1_val1_id, opt1_val2_id\&quot;, \&quot;opt2_id\&quot;: \&quot;opt2_val1_id\&quot; }\&quot;. (optional)
     * @param  int $product_filter_id Defines special filter based on product filter with specified identifier. (optional)
     * @param  bool $take_available_only Defines special filter for available product variants. (optional)
     * @param  string $sku SKU of linked ecommerce product. (optional)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementGetProductVariants'] to see the possible values for this operation
     *
     * @throws \Aurigma\BackOffice\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Aurigma\BackOffice\Model\PagedOfProductVariantDto|\Aurigma\BackOffice\Model\MicrosoftAspNetCoreMvcProblemDetails|\Aurigma\BackOffice\Model\GeneralConflictDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsManagementGetProductVariantsWithHttpInfo($id, $product_version_id = null, $skip = null, $take = null, $options = null, $product_filter_id = null, $take_available_only = null, $sku = null, $tenant_id = null, string $contentType = self::contentTypes['productsManagementGetProductVariants'][0])
    {
        $request = $this->productsManagementGetProductVariantsRequest($id, $product_version_id, $skip, $take, $options, $product_filter_id, $take_available_only, $sku, $tenant_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Aurigma\BackOffice\Model\PagedOfProductVariantDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Aurigma\BackOffice\Model\PagedOfProductVariantDto' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Aurigma\BackOffice\Model\PagedOfProductVariantDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\Aurigma\BackOffice\Model\MicrosoftAspNetCoreMvcProblemDetails' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Aurigma\BackOffice\Model\MicrosoftAspNetCoreMvcProblemDetails' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Aurigma\BackOffice\Model\MicrosoftAspNetCoreMvcProblemDetails', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\Aurigma\BackOffice\Model\GeneralConflictDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Aurigma\BackOffice\Model\GeneralConflictDto' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Aurigma\BackOffice\Model\GeneralConflictDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Aurigma\BackOffice\Model\PagedOfProductVariantDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurigma\BackOffice\Model\PagedOfProductVariantDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurigma\BackOffice\Model\MicrosoftAspNetCoreMvcProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurigma\BackOffice\Model\GeneralConflictDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsManagementGetProductVariantsAsync
     *
     * Returns a list of product variants.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $product_version_id Product version identifier. (optional)
     * @param  int $skip Defines page start offset from beginning of sorted result list. (optional)
     * @param  int $take Defines page length (how many consequent items of sorted result list should be taken). (optional)
     * @param  string $options Defines options filter e.g.: \&quot;{ \&quot;opt1_id\&quot;: \&quot;opt1_val1_id, opt1_val2_id\&quot;, \&quot;opt2_id\&quot;: \&quot;opt2_val1_id\&quot; }\&quot;. (optional)
     * @param  int $product_filter_id Defines special filter based on product filter with specified identifier. (optional)
     * @param  bool $take_available_only Defines special filter for available product variants. (optional)
     * @param  string $sku SKU of linked ecommerce product. (optional)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementGetProductVariants'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsManagementGetProductVariantsAsync($id, $product_version_id = null, $skip = null, $take = null, $options = null, $product_filter_id = null, $take_available_only = null, $sku = null, $tenant_id = null, string $contentType = self::contentTypes['productsManagementGetProductVariants'][0])
    {
        return $this->productsManagementGetProductVariantsAsyncWithHttpInfo($id, $product_version_id, $skip, $take, $options, $product_filter_id, $take_available_only, $sku, $tenant_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsManagementGetProductVariantsAsyncWithHttpInfo
     *
     * Returns a list of product variants.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $product_version_id Product version identifier. (optional)
     * @param  int $skip Defines page start offset from beginning of sorted result list. (optional)
     * @param  int $take Defines page length (how many consequent items of sorted result list should be taken). (optional)
     * @param  string $options Defines options filter e.g.: \&quot;{ \&quot;opt1_id\&quot;: \&quot;opt1_val1_id, opt1_val2_id\&quot;, \&quot;opt2_id\&quot;: \&quot;opt2_val1_id\&quot; }\&quot;. (optional)
     * @param  int $product_filter_id Defines special filter based on product filter with specified identifier. (optional)
     * @param  bool $take_available_only Defines special filter for available product variants. (optional)
     * @param  string $sku SKU of linked ecommerce product. (optional)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementGetProductVariants'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsManagementGetProductVariantsAsyncWithHttpInfo($id, $product_version_id = null, $skip = null, $take = null, $options = null, $product_filter_id = null, $take_available_only = null, $sku = null, $tenant_id = null, string $contentType = self::contentTypes['productsManagementGetProductVariants'][0])
    {
        $returnType = '\Aurigma\BackOffice\Model\PagedOfProductVariantDto';
        $request = $this->productsManagementGetProductVariantsRequest($id, $product_version_id, $skip, $take, $options, $product_filter_id, $take_available_only, $sku, $tenant_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsManagementGetProductVariants'
     *
     * @param  int $id Product identifier. (required)
     * @param  int $product_version_id Product version identifier. (optional)
     * @param  int $skip Defines page start offset from beginning of sorted result list. (optional)
     * @param  int $take Defines page length (how many consequent items of sorted result list should be taken). (optional)
     * @param  string $options Defines options filter e.g.: \&quot;{ \&quot;opt1_id\&quot;: \&quot;opt1_val1_id, opt1_val2_id\&quot;, \&quot;opt2_id\&quot;: \&quot;opt2_val1_id\&quot; }\&quot;. (optional)
     * @param  int $product_filter_id Defines special filter based on product filter with specified identifier. (optional)
     * @param  bool $take_available_only Defines special filter for available product variants. (optional)
     * @param  string $sku SKU of linked ecommerce product. (optional)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementGetProductVariants'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsManagementGetProductVariantsRequest($id, $product_version_id = null, $skip = null, $take = null, $options = null, $product_filter_id = null, $take_available_only = null, $sku = null, $tenant_id = null, string $contentType = self::contentTypes['productsManagementGetProductVariants'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productsManagementGetProductVariants'
            );
        }










        $resourcePath = '/api/backoffice/v1/products/{id}/variants';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $product_version_id,
            'productVersionId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $skip,
            'skip', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $take,
            'take', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $options,
            'options', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $product_filter_id,
            'productFilterId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $take_available_only,
            'takeAvailableOnly', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sku,
            'sku', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_id,
            'tenantId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsManagementImportProducts
     *
     * Imports products from a specific CSV file and returns a list of imported products descriptions.
     *
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  \SplFileObject $file CSV file with products data. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementImportProducts'] to see the possible values for this operation
     *
     * @throws \Aurigma\BackOffice\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Aurigma\BackOffice\Model\PagedOfProductDto|\Aurigma\BackOffice\Model\MicrosoftAspNetCoreMvcProblemDetails|\Aurigma\BackOffice\Model\GeneralConflictDto
     */
    public function productsManagementImportProducts($tenant_id = null, $file = null, string $contentType = self::contentTypes['productsManagementImportProducts'][0])
    {
        list($response) = $this->productsManagementImportProductsWithHttpInfo($tenant_id, $file, $contentType);
        return $response;
    }

    /**
     * Operation productsManagementImportProductsWithHttpInfo
     *
     * Imports products from a specific CSV file and returns a list of imported products descriptions.
     *
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  \SplFileObject $file CSV file with products data. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementImportProducts'] to see the possible values for this operation
     *
     * @throws \Aurigma\BackOffice\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Aurigma\BackOffice\Model\PagedOfProductDto|\Aurigma\BackOffice\Model\MicrosoftAspNetCoreMvcProblemDetails|\Aurigma\BackOffice\Model\GeneralConflictDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsManagementImportProductsWithHttpInfo($tenant_id = null, $file = null, string $contentType = self::contentTypes['productsManagementImportProducts'][0])
    {
        $request = $this->productsManagementImportProductsRequest($tenant_id, $file, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Aurigma\BackOffice\Model\PagedOfProductDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Aurigma\BackOffice\Model\PagedOfProductDto' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Aurigma\BackOffice\Model\PagedOfProductDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\Aurigma\BackOffice\Model\MicrosoftAspNetCoreMvcProblemDetails' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Aurigma\BackOffice\Model\MicrosoftAspNetCoreMvcProblemDetails' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Aurigma\BackOffice\Model\MicrosoftAspNetCoreMvcProblemDetails', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\Aurigma\BackOffice\Model\GeneralConflictDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Aurigma\BackOffice\Model\GeneralConflictDto' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Aurigma\BackOffice\Model\GeneralConflictDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Aurigma\BackOffice\Model\PagedOfProductDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurigma\BackOffice\Model\PagedOfProductDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurigma\BackOffice\Model\MicrosoftAspNetCoreMvcProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurigma\BackOffice\Model\GeneralConflictDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsManagementImportProductsAsync
     *
     * Imports products from a specific CSV file and returns a list of imported products descriptions.
     *
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  \SplFileObject $file CSV file with products data. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementImportProducts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsManagementImportProductsAsync($tenant_id = null, $file = null, string $contentType = self::contentTypes['productsManagementImportProducts'][0])
    {
        return $this->productsManagementImportProductsAsyncWithHttpInfo($tenant_id, $file, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsManagementImportProductsAsyncWithHttpInfo
     *
     * Imports products from a specific CSV file and returns a list of imported products descriptions.
     *
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  \SplFileObject $file CSV file with products data. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementImportProducts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsManagementImportProductsAsyncWithHttpInfo($tenant_id = null, $file = null, string $contentType = self::contentTypes['productsManagementImportProducts'][0])
    {
        $returnType = '\Aurigma\BackOffice\Model\PagedOfProductDto';
        $request = $this->productsManagementImportProductsRequest($tenant_id, $file, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsManagementImportProducts'
     *
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  \SplFileObject $file CSV file with products data. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementImportProducts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsManagementImportProductsRequest($tenant_id = null, $file = null, string $contentType = self::contentTypes['productsManagementImportProducts'][0])
    {




        $resourcePath = '/api/backoffice/v1/products/import';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_id,
            'tenantId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);



        // form params
        if ($file !== null) {
            $multipart = true;
            $formParams['file'] = [];
            $paramFiles = is_array($file) ? $file : [$file];
            foreach ($paramFiles as $paramFile) {
                $formParams['file'][] = \GuzzleHttp\Psr7\Utils::tryFopen(
                    ObjectSerializer::toFormValue($paramFile),
                    'rb'
                );
            }
        }

        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsManagementRemoveDesignsConnections
     *
     * Removes designs connections for a specified product.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  \Aurigma\BackOffice\Model\RemoveProductDesignConnectionsDto $remove_product_design_connections_dto Product designs connections creation parameters. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementRemoveDesignsConnections'] to see the possible values for this operation
     *
     * @throws \Aurigma\BackOffice\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function productsManagementRemoveDesignsConnections($id, $tenant_id = null, $remove_product_design_connections_dto = null, string $contentType = self::contentTypes['productsManagementRemoveDesignsConnections'][0])
    {
        $this->productsManagementRemoveDesignsConnectionsWithHttpInfo($id, $tenant_id, $remove_product_design_connections_dto, $contentType);
    }

    /**
     * Operation productsManagementRemoveDesignsConnectionsWithHttpInfo
     *
     * Removes designs connections for a specified product.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  \Aurigma\BackOffice\Model\RemoveProductDesignConnectionsDto $remove_product_design_connections_dto Product designs connections creation parameters. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementRemoveDesignsConnections'] to see the possible values for this operation
     *
     * @throws \Aurigma\BackOffice\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsManagementRemoveDesignsConnectionsWithHttpInfo($id, $tenant_id = null, $remove_product_design_connections_dto = null, string $contentType = self::contentTypes['productsManagementRemoveDesignsConnections'][0])
    {
        $request = $this->productsManagementRemoveDesignsConnectionsRequest($id, $tenant_id, $remove_product_design_connections_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurigma\BackOffice\Model\MicrosoftAspNetCoreMvcProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurigma\BackOffice\Model\GeneralConflictDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsManagementRemoveDesignsConnectionsAsync
     *
     * Removes designs connections for a specified product.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  \Aurigma\BackOffice\Model\RemoveProductDesignConnectionsDto $remove_product_design_connections_dto Product designs connections creation parameters. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementRemoveDesignsConnections'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsManagementRemoveDesignsConnectionsAsync($id, $tenant_id = null, $remove_product_design_connections_dto = null, string $contentType = self::contentTypes['productsManagementRemoveDesignsConnections'][0])
    {
        return $this->productsManagementRemoveDesignsConnectionsAsyncWithHttpInfo($id, $tenant_id, $remove_product_design_connections_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsManagementRemoveDesignsConnectionsAsyncWithHttpInfo
     *
     * Removes designs connections for a specified product.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  \Aurigma\BackOffice\Model\RemoveProductDesignConnectionsDto $remove_product_design_connections_dto Product designs connections creation parameters. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementRemoveDesignsConnections'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsManagementRemoveDesignsConnectionsAsyncWithHttpInfo($id, $tenant_id = null, $remove_product_design_connections_dto = null, string $contentType = self::contentTypes['productsManagementRemoveDesignsConnections'][0])
    {
        $returnType = '';
        $request = $this->productsManagementRemoveDesignsConnectionsRequest($id, $tenant_id, $remove_product_design_connections_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsManagementRemoveDesignsConnections'
     *
     * @param  int $id Product identifier. (required)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  \Aurigma\BackOffice\Model\RemoveProductDesignConnectionsDto $remove_product_design_connections_dto Product designs connections creation parameters. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementRemoveDesignsConnections'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsManagementRemoveDesignsConnectionsRequest($id, $tenant_id = null, $remove_product_design_connections_dto = null, string $contentType = self::contentTypes['productsManagementRemoveDesignsConnections'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productsManagementRemoveDesignsConnections'
            );
        }




        $resourcePath = '/api/backoffice/v1/products/{id}/design-connections';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_id,
            'tenantId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($remove_product_design_connections_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($remove_product_design_connections_dto));
            } else {
                $httpBody = $remove_product_design_connections_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsManagementRemoveDocumentsConnections
     *
     * Removes documents connections for a specified product.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  \Aurigma\BackOffice\Model\RemoveProductDocumentConnectionsDto $remove_product_document_connections_dto Product documents connections creation parameters. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementRemoveDocumentsConnections'] to see the possible values for this operation
     *
     * @throws \Aurigma\BackOffice\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function productsManagementRemoveDocumentsConnections($id, $tenant_id = null, $remove_product_document_connections_dto = null, string $contentType = self::contentTypes['productsManagementRemoveDocumentsConnections'][0])
    {
        $this->productsManagementRemoveDocumentsConnectionsWithHttpInfo($id, $tenant_id, $remove_product_document_connections_dto, $contentType);
    }

    /**
     * Operation productsManagementRemoveDocumentsConnectionsWithHttpInfo
     *
     * Removes documents connections for a specified product.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  \Aurigma\BackOffice\Model\RemoveProductDocumentConnectionsDto $remove_product_document_connections_dto Product documents connections creation parameters. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementRemoveDocumentsConnections'] to see the possible values for this operation
     *
     * @throws \Aurigma\BackOffice\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsManagementRemoveDocumentsConnectionsWithHttpInfo($id, $tenant_id = null, $remove_product_document_connections_dto = null, string $contentType = self::contentTypes['productsManagementRemoveDocumentsConnections'][0])
    {
        $request = $this->productsManagementRemoveDocumentsConnectionsRequest($id, $tenant_id, $remove_product_document_connections_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurigma\BackOffice\Model\MicrosoftAspNetCoreMvcProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurigma\BackOffice\Model\GeneralConflictDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsManagementRemoveDocumentsConnectionsAsync
     *
     * Removes documents connections for a specified product.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  \Aurigma\BackOffice\Model\RemoveProductDocumentConnectionsDto $remove_product_document_connections_dto Product documents connections creation parameters. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementRemoveDocumentsConnections'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsManagementRemoveDocumentsConnectionsAsync($id, $tenant_id = null, $remove_product_document_connections_dto = null, string $contentType = self::contentTypes['productsManagementRemoveDocumentsConnections'][0])
    {
        return $this->productsManagementRemoveDocumentsConnectionsAsyncWithHttpInfo($id, $tenant_id, $remove_product_document_connections_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsManagementRemoveDocumentsConnectionsAsyncWithHttpInfo
     *
     * Removes documents connections for a specified product.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  \Aurigma\BackOffice\Model\RemoveProductDocumentConnectionsDto $remove_product_document_connections_dto Product documents connections creation parameters. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementRemoveDocumentsConnections'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsManagementRemoveDocumentsConnectionsAsyncWithHttpInfo($id, $tenant_id = null, $remove_product_document_connections_dto = null, string $contentType = self::contentTypes['productsManagementRemoveDocumentsConnections'][0])
    {
        $returnType = '';
        $request = $this->productsManagementRemoveDocumentsConnectionsRequest($id, $tenant_id, $remove_product_document_connections_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsManagementRemoveDocumentsConnections'
     *
     * @param  int $id Product identifier. (required)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  \Aurigma\BackOffice\Model\RemoveProductDocumentConnectionsDto $remove_product_document_connections_dto Product documents connections creation parameters. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementRemoveDocumentsConnections'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsManagementRemoveDocumentsConnectionsRequest($id, $tenant_id = null, $remove_product_document_connections_dto = null, string $contentType = self::contentTypes['productsManagementRemoveDocumentsConnections'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productsManagementRemoveDocumentsConnections'
            );
        }




        $resourcePath = '/api/backoffice/v1/products/{id}/document-connections';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_id,
            'tenantId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($remove_product_document_connections_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($remove_product_document_connections_dto));
            } else {
                $httpBody = $remove_product_document_connections_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsManagementRemoveMockupsConnections
     *
     * Removes mockups connections for a specified product.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  \Aurigma\BackOffice\Model\RemoveProductMockupConnectionsDto $remove_product_mockup_connections_dto Product mockups connections creation parameters. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementRemoveMockupsConnections'] to see the possible values for this operation
     *
     * @throws \Aurigma\BackOffice\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function productsManagementRemoveMockupsConnections($id, $tenant_id = null, $remove_product_mockup_connections_dto = null, string $contentType = self::contentTypes['productsManagementRemoveMockupsConnections'][0])
    {
        $this->productsManagementRemoveMockupsConnectionsWithHttpInfo($id, $tenant_id, $remove_product_mockup_connections_dto, $contentType);
    }

    /**
     * Operation productsManagementRemoveMockupsConnectionsWithHttpInfo
     *
     * Removes mockups connections for a specified product.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  \Aurigma\BackOffice\Model\RemoveProductMockupConnectionsDto $remove_product_mockup_connections_dto Product mockups connections creation parameters. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementRemoveMockupsConnections'] to see the possible values for this operation
     *
     * @throws \Aurigma\BackOffice\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsManagementRemoveMockupsConnectionsWithHttpInfo($id, $tenant_id = null, $remove_product_mockup_connections_dto = null, string $contentType = self::contentTypes['productsManagementRemoveMockupsConnections'][0])
    {
        $request = $this->productsManagementRemoveMockupsConnectionsRequest($id, $tenant_id, $remove_product_mockup_connections_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurigma\BackOffice\Model\MicrosoftAspNetCoreMvcProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurigma\BackOffice\Model\GeneralConflictDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsManagementRemoveMockupsConnectionsAsync
     *
     * Removes mockups connections for a specified product.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  \Aurigma\BackOffice\Model\RemoveProductMockupConnectionsDto $remove_product_mockup_connections_dto Product mockups connections creation parameters. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementRemoveMockupsConnections'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsManagementRemoveMockupsConnectionsAsync($id, $tenant_id = null, $remove_product_mockup_connections_dto = null, string $contentType = self::contentTypes['productsManagementRemoveMockupsConnections'][0])
    {
        return $this->productsManagementRemoveMockupsConnectionsAsyncWithHttpInfo($id, $tenant_id, $remove_product_mockup_connections_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsManagementRemoveMockupsConnectionsAsyncWithHttpInfo
     *
     * Removes mockups connections for a specified product.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  \Aurigma\BackOffice\Model\RemoveProductMockupConnectionsDto $remove_product_mockup_connections_dto Product mockups connections creation parameters. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementRemoveMockupsConnections'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsManagementRemoveMockupsConnectionsAsyncWithHttpInfo($id, $tenant_id = null, $remove_product_mockup_connections_dto = null, string $contentType = self::contentTypes['productsManagementRemoveMockupsConnections'][0])
    {
        $returnType = '';
        $request = $this->productsManagementRemoveMockupsConnectionsRequest($id, $tenant_id, $remove_product_mockup_connections_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsManagementRemoveMockupsConnections'
     *
     * @param  int $id Product identifier. (required)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  \Aurigma\BackOffice\Model\RemoveProductMockupConnectionsDto $remove_product_mockup_connections_dto Product mockups connections creation parameters. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementRemoveMockupsConnections'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsManagementRemoveMockupsConnectionsRequest($id, $tenant_id = null, $remove_product_mockup_connections_dto = null, string $contentType = self::contentTypes['productsManagementRemoveMockupsConnections'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productsManagementRemoveMockupsConnections'
            );
        }




        $resourcePath = '/api/backoffice/v1/products/{id}/mockup-connections';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_id,
            'tenantId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($remove_product_mockup_connections_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($remove_product_mockup_connections_dto));
            } else {
                $httpBody = $remove_product_mockup_connections_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsManagementSetProductVariantAvailability
     *
     * Set product variants availability. Variants identifiers will be changed.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  \Aurigma\BackOffice\Model\SetProductVariantAvailabilityDto $set_product_variant_availability_dto Set product variants availability operation parameters. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementSetProductVariantAvailability'] to see the possible values for this operation
     *
     * @throws \Aurigma\BackOffice\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function productsManagementSetProductVariantAvailability($id, $tenant_id = null, $set_product_variant_availability_dto = null, string $contentType = self::contentTypes['productsManagementSetProductVariantAvailability'][0])
    {
        $this->productsManagementSetProductVariantAvailabilityWithHttpInfo($id, $tenant_id, $set_product_variant_availability_dto, $contentType);
    }

    /**
     * Operation productsManagementSetProductVariantAvailabilityWithHttpInfo
     *
     * Set product variants availability. Variants identifiers will be changed.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  \Aurigma\BackOffice\Model\SetProductVariantAvailabilityDto $set_product_variant_availability_dto Set product variants availability operation parameters. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementSetProductVariantAvailability'] to see the possible values for this operation
     *
     * @throws \Aurigma\BackOffice\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsManagementSetProductVariantAvailabilityWithHttpInfo($id, $tenant_id = null, $set_product_variant_availability_dto = null, string $contentType = self::contentTypes['productsManagementSetProductVariantAvailability'][0])
    {
        $request = $this->productsManagementSetProductVariantAvailabilityRequest($id, $tenant_id, $set_product_variant_availability_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurigma\BackOffice\Model\MicrosoftAspNetCoreMvcProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurigma\BackOffice\Model\GeneralConflictDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsManagementSetProductVariantAvailabilityAsync
     *
     * Set product variants availability. Variants identifiers will be changed.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  \Aurigma\BackOffice\Model\SetProductVariantAvailabilityDto $set_product_variant_availability_dto Set product variants availability operation parameters. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementSetProductVariantAvailability'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsManagementSetProductVariantAvailabilityAsync($id, $tenant_id = null, $set_product_variant_availability_dto = null, string $contentType = self::contentTypes['productsManagementSetProductVariantAvailability'][0])
    {
        return $this->productsManagementSetProductVariantAvailabilityAsyncWithHttpInfo($id, $tenant_id, $set_product_variant_availability_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsManagementSetProductVariantAvailabilityAsyncWithHttpInfo
     *
     * Set product variants availability. Variants identifiers will be changed.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  \Aurigma\BackOffice\Model\SetProductVariantAvailabilityDto $set_product_variant_availability_dto Set product variants availability operation parameters. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementSetProductVariantAvailability'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsManagementSetProductVariantAvailabilityAsyncWithHttpInfo($id, $tenant_id = null, $set_product_variant_availability_dto = null, string $contentType = self::contentTypes['productsManagementSetProductVariantAvailability'][0])
    {
        $returnType = '';
        $request = $this->productsManagementSetProductVariantAvailabilityRequest($id, $tenant_id, $set_product_variant_availability_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsManagementSetProductVariantAvailability'
     *
     * @param  int $id Product identifier. (required)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  \Aurigma\BackOffice\Model\SetProductVariantAvailabilityDto $set_product_variant_availability_dto Set product variants availability operation parameters. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementSetProductVariantAvailability'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsManagementSetProductVariantAvailabilityRequest($id, $tenant_id = null, $set_product_variant_availability_dto = null, string $contentType = self::contentTypes['productsManagementSetProductVariantAvailability'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productsManagementSetProductVariantAvailability'
            );
        }




        $resourcePath = '/api/backoffice/v1/products/{id}/set-variant-availability';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_id,
            'tenantId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($set_product_variant_availability_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($set_product_variant_availability_dto));
            } else {
                $httpBody = $set_product_variant_availability_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsManagementSetProductVariantPrice
     *
     * Set product variants price. Variants identifiers will be changed.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  \Aurigma\BackOffice\Model\SetProductVariantPriceDto $set_product_variant_price_dto Set product variants price operation parameters. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementSetProductVariantPrice'] to see the possible values for this operation
     *
     * @throws \Aurigma\BackOffice\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function productsManagementSetProductVariantPrice($id, $tenant_id = null, $set_product_variant_price_dto = null, string $contentType = self::contentTypes['productsManagementSetProductVariantPrice'][0])
    {
        $this->productsManagementSetProductVariantPriceWithHttpInfo($id, $tenant_id, $set_product_variant_price_dto, $contentType);
    }

    /**
     * Operation productsManagementSetProductVariantPriceWithHttpInfo
     *
     * Set product variants price. Variants identifiers will be changed.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  \Aurigma\BackOffice\Model\SetProductVariantPriceDto $set_product_variant_price_dto Set product variants price operation parameters. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementSetProductVariantPrice'] to see the possible values for this operation
     *
     * @throws \Aurigma\BackOffice\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsManagementSetProductVariantPriceWithHttpInfo($id, $tenant_id = null, $set_product_variant_price_dto = null, string $contentType = self::contentTypes['productsManagementSetProductVariantPrice'][0])
    {
        $request = $this->productsManagementSetProductVariantPriceRequest($id, $tenant_id, $set_product_variant_price_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurigma\BackOffice\Model\MicrosoftAspNetCoreMvcProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurigma\BackOffice\Model\GeneralConflictDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsManagementSetProductVariantPriceAsync
     *
     * Set product variants price. Variants identifiers will be changed.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  \Aurigma\BackOffice\Model\SetProductVariantPriceDto $set_product_variant_price_dto Set product variants price operation parameters. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementSetProductVariantPrice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsManagementSetProductVariantPriceAsync($id, $tenant_id = null, $set_product_variant_price_dto = null, string $contentType = self::contentTypes['productsManagementSetProductVariantPrice'][0])
    {
        return $this->productsManagementSetProductVariantPriceAsyncWithHttpInfo($id, $tenant_id, $set_product_variant_price_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsManagementSetProductVariantPriceAsyncWithHttpInfo
     *
     * Set product variants price. Variants identifiers will be changed.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  \Aurigma\BackOffice\Model\SetProductVariantPriceDto $set_product_variant_price_dto Set product variants price operation parameters. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementSetProductVariantPrice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsManagementSetProductVariantPriceAsyncWithHttpInfo($id, $tenant_id = null, $set_product_variant_price_dto = null, string $contentType = self::contentTypes['productsManagementSetProductVariantPrice'][0])
    {
        $returnType = '';
        $request = $this->productsManagementSetProductVariantPriceRequest($id, $tenant_id, $set_product_variant_price_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsManagementSetProductVariantPrice'
     *
     * @param  int $id Product identifier. (required)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  \Aurigma\BackOffice\Model\SetProductVariantPriceDto $set_product_variant_price_dto Set product variants price operation parameters. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementSetProductVariantPrice'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsManagementSetProductVariantPriceRequest($id, $tenant_id = null, $set_product_variant_price_dto = null, string $contentType = self::contentTypes['productsManagementSetProductVariantPrice'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productsManagementSetProductVariantPrice'
            );
        }




        $resourcePath = '/api/backoffice/v1/products/{id}/set-variant-price';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_id,
            'tenantId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($set_product_variant_price_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($set_product_variant_price_dto));
            } else {
                $httpBody = $set_product_variant_price_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation productsManagementSetProductVariantSku
     *
     * Set product variants SKU. Variants identifiers will be changed.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  \Aurigma\BackOffice\Model\SetProductVariantSkuDto $set_product_variant_sku_dto Set product variants SKU operation parameters. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementSetProductVariantSku'] to see the possible values for this operation
     *
     * @throws \Aurigma\BackOffice\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function productsManagementSetProductVariantSku($id, $tenant_id = null, $set_product_variant_sku_dto = null, string $contentType = self::contentTypes['productsManagementSetProductVariantSku'][0])
    {
        $this->productsManagementSetProductVariantSkuWithHttpInfo($id, $tenant_id, $set_product_variant_sku_dto, $contentType);
    }

    /**
     * Operation productsManagementSetProductVariantSkuWithHttpInfo
     *
     * Set product variants SKU. Variants identifiers will be changed.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  \Aurigma\BackOffice\Model\SetProductVariantSkuDto $set_product_variant_sku_dto Set product variants SKU operation parameters. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementSetProductVariantSku'] to see the possible values for this operation
     *
     * @throws \Aurigma\BackOffice\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function productsManagementSetProductVariantSkuWithHttpInfo($id, $tenant_id = null, $set_product_variant_sku_dto = null, string $contentType = self::contentTypes['productsManagementSetProductVariantSku'][0])
    {
        $request = $this->productsManagementSetProductVariantSkuRequest($id, $tenant_id, $set_product_variant_sku_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurigma\BackOffice\Model\MicrosoftAspNetCoreMvcProblemDetails',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Aurigma\BackOffice\Model\GeneralConflictDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation productsManagementSetProductVariantSkuAsync
     *
     * Set product variants SKU. Variants identifiers will be changed.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  \Aurigma\BackOffice\Model\SetProductVariantSkuDto $set_product_variant_sku_dto Set product variants SKU operation parameters. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementSetProductVariantSku'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsManagementSetProductVariantSkuAsync($id, $tenant_id = null, $set_product_variant_sku_dto = null, string $contentType = self::contentTypes['productsManagementSetProductVariantSku'][0])
    {
        return $this->productsManagementSetProductVariantSkuAsyncWithHttpInfo($id, $tenant_id, $set_product_variant_sku_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation productsManagementSetProductVariantSkuAsyncWithHttpInfo
     *
     * Set product variants SKU. Variants identifiers will be changed.
     *
     * @param  int $id Product identifier. (required)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  \Aurigma\BackOffice\Model\SetProductVariantSkuDto $set_product_variant_sku_dto Set product variants SKU operation parameters. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementSetProductVariantSku'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function productsManagementSetProductVariantSkuAsyncWithHttpInfo($id, $tenant_id = null, $set_product_variant_sku_dto = null, string $contentType = self::contentTypes['productsManagementSetProductVariantSku'][0])
    {
        $returnType = '';
        $request = $this->productsManagementSetProductVariantSkuRequest($id, $tenant_id, $set_product_variant_sku_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'productsManagementSetProductVariantSku'
     *
     * @param  int $id Product identifier. (required)
     * @param  int $tenant_id Tenant identifier. (optional)
     * @param  \Aurigma\BackOffice\Model\SetProductVariantSkuDto $set_product_variant_sku_dto Set product variants SKU operation parameters. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['productsManagementSetProductVariantSku'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function productsManagementSetProductVariantSkuRequest($id, $tenant_id = null, $set_product_variant_sku_dto = null, string $contentType = self::contentTypes['productsManagementSetProductVariantSku'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling productsManagementSetProductVariantSku'
            );
        }




        $resourcePath = '/api/backoffice/v1/products/{id}/set-variant-sku';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_id,
            'tenantId', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($set_product_variant_sku_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($set_product_variant_sku_dto));
            } else {
                $httpBody = $set_product_variant_sku_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-Key');
        if ($apiKey !== null) {
            $headers['X-API-Key'] = $apiKey;
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
